# coding: utf-8

"""
    App Store Connect API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 4.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from openapi_client.models.accessibility_declarations_response import AccessibilityDeclarationsResponse
from openapi_client.models.alternative_distribution_key_response import AlternativeDistributionKeyResponse
from openapi_client.models.analytics_report_requests_response import AnalyticsReportRequestsResponse
from openapi_client.models.app_accessibility_declarations_linkages_response import AppAccessibilityDeclarationsLinkagesResponse
from openapi_client.models.app_alternative_distribution_key_linkage_response import AppAlternativeDistributionKeyLinkageResponse
from openapi_client.models.app_analytics_report_requests_linkages_response import AppAnalyticsReportRequestsLinkagesResponse
from openapi_client.models.app_app_availability_v2_linkage_response import AppAppAvailabilityV2LinkageResponse
from openapi_client.models.app_app_clips_linkages_response import AppAppClipsLinkagesResponse
from openapi_client.models.app_app_custom_product_pages_linkages_response import AppAppCustomProductPagesLinkagesResponse
from openapi_client.models.app_app_encryption_declarations_linkages_response import AppAppEncryptionDeclarationsLinkagesResponse
from openapi_client.models.app_app_events_linkages_response import AppAppEventsLinkagesResponse
from openapi_client.models.app_app_infos_linkages_response import AppAppInfosLinkagesResponse
from openapi_client.models.app_app_price_points_linkages_response import AppAppPricePointsLinkagesResponse
from openapi_client.models.app_app_price_schedule_linkage_response import AppAppPriceScheduleLinkageResponse
from openapi_client.models.app_app_store_version_experiments_v2_linkages_response import AppAppStoreVersionExperimentsV2LinkagesResponse
from openapi_client.models.app_app_store_versions_linkages_response import AppAppStoreVersionsLinkagesResponse
from openapi_client.models.app_availability_v2_response import AppAvailabilityV2Response
from openapi_client.models.app_background_assets_linkages_response import AppBackgroundAssetsLinkagesResponse
from openapi_client.models.app_beta_app_localizations_linkages_response import AppBetaAppLocalizationsLinkagesResponse
from openapi_client.models.app_beta_app_review_detail_linkage_response import AppBetaAppReviewDetailLinkageResponse
from openapi_client.models.app_beta_feedback_crash_submissions_linkages_response import AppBetaFeedbackCrashSubmissionsLinkagesResponse
from openapi_client.models.app_beta_feedback_screenshot_submissions_linkages_response import AppBetaFeedbackScreenshotSubmissionsLinkagesResponse
from openapi_client.models.app_beta_groups_linkages_response import AppBetaGroupsLinkagesResponse
from openapi_client.models.app_beta_license_agreement_linkage_response import AppBetaLicenseAgreementLinkageResponse
from openapi_client.models.app_beta_testers_linkages_request import AppBetaTestersLinkagesRequest
from openapi_client.models.app_builds_linkages_response import AppBuildsLinkagesResponse
from openapi_client.models.app_ci_product_linkage_response import AppCiProductLinkageResponse
from openapi_client.models.app_clips_response import AppClipsResponse
from openapi_client.models.app_custom_product_pages_response import AppCustomProductPagesResponse
from openapi_client.models.app_customer_reviews_linkages_response import AppCustomerReviewsLinkagesResponse
from openapi_client.models.app_encryption_declarations_response import AppEncryptionDeclarationsResponse
from openapi_client.models.app_end_user_license_agreement_linkage_response import AppEndUserLicenseAgreementLinkageResponse
from openapi_client.models.app_events_response import AppEventsResponse
from openapi_client.models.app_game_center_detail_linkage_response import AppGameCenterDetailLinkageResponse
from openapi_client.models.app_game_center_enabled_versions_linkages_response import AppGameCenterEnabledVersionsLinkagesResponse
from openapi_client.models.app_in_app_purchases_linkages_response import AppInAppPurchasesLinkagesResponse
from openapi_client.models.app_in_app_purchases_v2_linkages_response import AppInAppPurchasesV2LinkagesResponse
from openapi_client.models.app_infos_response import AppInfosResponse
from openapi_client.models.app_marketplace_search_detail_linkage_response import AppMarketplaceSearchDetailLinkageResponse
from openapi_client.models.app_pre_release_versions_linkages_response import AppPreReleaseVersionsLinkagesResponse
from openapi_client.models.app_price_points_v3_response import AppPricePointsV3Response
from openapi_client.models.app_price_schedule_response import AppPriceScheduleResponse
from openapi_client.models.app_promoted_purchases_linkages_request import AppPromotedPurchasesLinkagesRequest
from openapi_client.models.app_promoted_purchases_linkages_response import AppPromotedPurchasesLinkagesResponse
from openapi_client.models.app_response import AppResponse
from openapi_client.models.app_review_submissions_linkages_response import AppReviewSubmissionsLinkagesResponse
from openapi_client.models.app_store_version_experiments_v2_response import AppStoreVersionExperimentsV2Response
from openapi_client.models.app_store_versions_response import AppStoreVersionsResponse
from openapi_client.models.app_subscription_grace_period_linkage_response import AppSubscriptionGracePeriodLinkageResponse
from openapi_client.models.app_subscription_groups_linkages_response import AppSubscriptionGroupsLinkagesResponse
from openapi_client.models.app_update_request import AppUpdateRequest
from openapi_client.models.app_webhooks_linkages_response import AppWebhooksLinkagesResponse
from openapi_client.models.apps_beta_tester_usages_v1_metric_response import AppsBetaTesterUsagesV1MetricResponse
from openapi_client.models.apps_response import AppsResponse
from openapi_client.models.background_assets_response import BackgroundAssetsResponse
from openapi_client.models.beta_app_localizations_without_includes_response import BetaAppLocalizationsWithoutIncludesResponse
from openapi_client.models.beta_app_review_detail_without_includes_response import BetaAppReviewDetailWithoutIncludesResponse
from openapi_client.models.beta_feedback_crash_submissions_response import BetaFeedbackCrashSubmissionsResponse
from openapi_client.models.beta_feedback_screenshot_submissions_response import BetaFeedbackScreenshotSubmissionsResponse
from openapi_client.models.beta_groups_without_includes_response import BetaGroupsWithoutIncludesResponse
from openapi_client.models.beta_license_agreement_without_includes_response import BetaLicenseAgreementWithoutIncludesResponse
from openapi_client.models.builds_without_includes_response import BuildsWithoutIncludesResponse
from openapi_client.models.ci_product_response import CiProductResponse
from openapi_client.models.customer_review_summarizations_response import CustomerReviewSummarizationsResponse
from openapi_client.models.customer_reviews_response import CustomerReviewsResponse
from openapi_client.models.end_user_license_agreement_without_includes_response import EndUserLicenseAgreementWithoutIncludesResponse
from openapi_client.models.game_center_detail_response import GameCenterDetailResponse
from openapi_client.models.game_center_enabled_versions_response import GameCenterEnabledVersionsResponse
from openapi_client.models.in_app_purchases_response import InAppPurchasesResponse
from openapi_client.models.in_app_purchases_v2_response import InAppPurchasesV2Response
from openapi_client.models.marketplace_search_detail_response import MarketplaceSearchDetailResponse
from openapi_client.models.pre_release_versions_without_includes_response import PreReleaseVersionsWithoutIncludesResponse
from openapi_client.models.promoted_purchases_response import PromotedPurchasesResponse
from openapi_client.models.review_submissions_response import ReviewSubmissionsResponse
from openapi_client.models.subscription_grace_period_response import SubscriptionGracePeriodResponse
from openapi_client.models.subscription_groups_response import SubscriptionGroupsResponse
from openapi_client.models.webhooks_response import WebhooksResponse
from openapi_client.models.xcode_metrics import XcodeMetrics

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class AppsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def apps_accessibility_declarations_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_device_family: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceFamily'")] = None,
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        fields_accessibility_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type accessibilityDeclarations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccessibilityDeclarationsResponse:
        """apps_accessibility_declarations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_device_family: filter by attribute 'deviceFamily'
        :type filter_device_family: List[str]
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param fields_accessibility_declarations: the fields to include for returned resources of type accessibilityDeclarations
        :type fields_accessibility_declarations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_accessibility_declarations_get_to_many_related_serialize(
            id=id,
            filter_device_family=filter_device_family,
            filter_state=filter_state,
            fields_accessibility_declarations=fields_accessibility_declarations,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AccessibilityDeclarationsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_accessibility_declarations_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_device_family: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceFamily'")] = None,
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        fields_accessibility_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type accessibilityDeclarations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccessibilityDeclarationsResponse]:
        """apps_accessibility_declarations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_device_family: filter by attribute 'deviceFamily'
        :type filter_device_family: List[str]
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param fields_accessibility_declarations: the fields to include for returned resources of type accessibilityDeclarations
        :type fields_accessibility_declarations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_accessibility_declarations_get_to_many_related_serialize(
            id=id,
            filter_device_family=filter_device_family,
            filter_state=filter_state,
            fields_accessibility_declarations=fields_accessibility_declarations,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AccessibilityDeclarationsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_accessibility_declarations_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_device_family: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceFamily'")] = None,
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        fields_accessibility_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type accessibilityDeclarations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_accessibility_declarations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_device_family: filter by attribute 'deviceFamily'
        :type filter_device_family: List[str]
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param fields_accessibility_declarations: the fields to include for returned resources of type accessibilityDeclarations
        :type fields_accessibility_declarations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_accessibility_declarations_get_to_many_related_serialize(
            id=id,
            filter_device_family=filter_device_family,
            filter_state=filter_state,
            fields_accessibility_declarations=fields_accessibility_declarations,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AccessibilityDeclarationsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_accessibility_declarations_get_to_many_related_serialize(
        self,
        id,
        filter_device_family,
        filter_state,
        fields_accessibility_declarations,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[deviceFamily]': 'csv',
            'filter[state]': 'csv',
            'fields[accessibilityDeclarations]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_device_family is not None:
            
            _query_params.append(('filter[deviceFamily]', filter_device_family))
            
        if filter_state is not None:
            
            _query_params.append(('filter[state]', filter_state))
            
        if fields_accessibility_declarations is not None:
            
            _query_params.append(('fields[accessibilityDeclarations]', fields_accessibility_declarations))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/accessibilityDeclarations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_accessibility_declarations_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAccessibilityDeclarationsLinkagesResponse:
        """apps_accessibility_declarations_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_accessibility_declarations_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAccessibilityDeclarationsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_accessibility_declarations_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAccessibilityDeclarationsLinkagesResponse]:
        """apps_accessibility_declarations_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_accessibility_declarations_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAccessibilityDeclarationsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_accessibility_declarations_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_accessibility_declarations_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_accessibility_declarations_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAccessibilityDeclarationsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_accessibility_declarations_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/accessibilityDeclarations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_alternative_distribution_key_get_to_one_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_alternative_distribution_keys: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type alternativeDistributionKeys")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AlternativeDistributionKeyResponse:
        """apps_alternative_distribution_key_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_alternative_distribution_keys: the fields to include for returned resources of type alternativeDistributionKeys
        :type fields_alternative_distribution_keys: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_alternative_distribution_key_get_to_one_related_serialize(
            id=id,
            fields_alternative_distribution_keys=fields_alternative_distribution_keys,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AlternativeDistributionKeyResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_alternative_distribution_key_get_to_one_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_alternative_distribution_keys: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type alternativeDistributionKeys")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AlternativeDistributionKeyResponse]:
        """apps_alternative_distribution_key_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_alternative_distribution_keys: the fields to include for returned resources of type alternativeDistributionKeys
        :type fields_alternative_distribution_keys: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_alternative_distribution_key_get_to_one_related_serialize(
            id=id,
            fields_alternative_distribution_keys=fields_alternative_distribution_keys,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AlternativeDistributionKeyResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_alternative_distribution_key_get_to_one_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_alternative_distribution_keys: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type alternativeDistributionKeys")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_alternative_distribution_key_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_alternative_distribution_keys: the fields to include for returned resources of type alternativeDistributionKeys
        :type fields_alternative_distribution_keys: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_alternative_distribution_key_get_to_one_related_serialize(
            id=id,
            fields_alternative_distribution_keys=fields_alternative_distribution_keys,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AlternativeDistributionKeyResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_alternative_distribution_key_get_to_one_related_serialize(
        self,
        id,
        fields_alternative_distribution_keys,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[alternativeDistributionKeys]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_alternative_distribution_keys is not None:
            
            _query_params.append(('fields[alternativeDistributionKeys]', fields_alternative_distribution_keys))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/alternativeDistributionKey',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_alternative_distribution_key_get_to_one_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAlternativeDistributionKeyLinkageResponse:
        """apps_alternative_distribution_key_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_alternative_distribution_key_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAlternativeDistributionKeyLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_alternative_distribution_key_get_to_one_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAlternativeDistributionKeyLinkageResponse]:
        """apps_alternative_distribution_key_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_alternative_distribution_key_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAlternativeDistributionKeyLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_alternative_distribution_key_get_to_one_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_alternative_distribution_key_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_alternative_distribution_key_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAlternativeDistributionKeyLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_alternative_distribution_key_get_to_one_relationship_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/alternativeDistributionKey',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_analytics_report_requests_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_access_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'accessType'")] = None,
        fields_analytics_report_requests: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type analyticsReportRequests")] = None,
        fields_analytics_reports: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type analyticsReports")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_reports: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related reports returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnalyticsReportRequestsResponse:
        """apps_analytics_report_requests_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_access_type: filter by attribute 'accessType'
        :type filter_access_type: List[str]
        :param fields_analytics_report_requests: the fields to include for returned resources of type analyticsReportRequests
        :type fields_analytics_report_requests: List[str]
        :param fields_analytics_reports: the fields to include for returned resources of type analyticsReports
        :type fields_analytics_reports: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_reports: maximum number of related reports returned (when they are included)
        :type limit_reports: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_analytics_report_requests_get_to_many_related_serialize(
            id=id,
            filter_access_type=filter_access_type,
            fields_analytics_report_requests=fields_analytics_report_requests,
            fields_analytics_reports=fields_analytics_reports,
            limit=limit,
            include=include,
            limit_reports=limit_reports,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AnalyticsReportRequestsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_analytics_report_requests_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_access_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'accessType'")] = None,
        fields_analytics_report_requests: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type analyticsReportRequests")] = None,
        fields_analytics_reports: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type analyticsReports")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_reports: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related reports returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnalyticsReportRequestsResponse]:
        """apps_analytics_report_requests_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_access_type: filter by attribute 'accessType'
        :type filter_access_type: List[str]
        :param fields_analytics_report_requests: the fields to include for returned resources of type analyticsReportRequests
        :type fields_analytics_report_requests: List[str]
        :param fields_analytics_reports: the fields to include for returned resources of type analyticsReports
        :type fields_analytics_reports: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_reports: maximum number of related reports returned (when they are included)
        :type limit_reports: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_analytics_report_requests_get_to_many_related_serialize(
            id=id,
            filter_access_type=filter_access_type,
            fields_analytics_report_requests=fields_analytics_report_requests,
            fields_analytics_reports=fields_analytics_reports,
            limit=limit,
            include=include,
            limit_reports=limit_reports,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AnalyticsReportRequestsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_analytics_report_requests_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_access_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'accessType'")] = None,
        fields_analytics_report_requests: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type analyticsReportRequests")] = None,
        fields_analytics_reports: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type analyticsReports")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_reports: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related reports returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_analytics_report_requests_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_access_type: filter by attribute 'accessType'
        :type filter_access_type: List[str]
        :param fields_analytics_report_requests: the fields to include for returned resources of type analyticsReportRequests
        :type fields_analytics_report_requests: List[str]
        :param fields_analytics_reports: the fields to include for returned resources of type analyticsReports
        :type fields_analytics_reports: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_reports: maximum number of related reports returned (when they are included)
        :type limit_reports: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_analytics_report_requests_get_to_many_related_serialize(
            id=id,
            filter_access_type=filter_access_type,
            fields_analytics_report_requests=fields_analytics_report_requests,
            fields_analytics_reports=fields_analytics_reports,
            limit=limit,
            include=include,
            limit_reports=limit_reports,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AnalyticsReportRequestsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_analytics_report_requests_get_to_many_related_serialize(
        self,
        id,
        filter_access_type,
        fields_analytics_report_requests,
        fields_analytics_reports,
        limit,
        include,
        limit_reports,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[accessType]': 'csv',
            'fields[analyticsReportRequests]': 'csv',
            'fields[analyticsReports]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_access_type is not None:
            
            _query_params.append(('filter[accessType]', filter_access_type))
            
        if fields_analytics_report_requests is not None:
            
            _query_params.append(('fields[analyticsReportRequests]', fields_analytics_report_requests))
            
        if fields_analytics_reports is not None:
            
            _query_params.append(('fields[analyticsReports]', fields_analytics_reports))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_reports is not None:
            
            _query_params.append(('limit[reports]', limit_reports))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/analyticsReportRequests',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_analytics_report_requests_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAnalyticsReportRequestsLinkagesResponse:
        """apps_analytics_report_requests_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_analytics_report_requests_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAnalyticsReportRequestsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_analytics_report_requests_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAnalyticsReportRequestsLinkagesResponse]:
        """apps_analytics_report_requests_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_analytics_report_requests_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAnalyticsReportRequestsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_analytics_report_requests_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_analytics_report_requests_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_analytics_report_requests_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAnalyticsReportRequestsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_analytics_report_requests_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/analyticsReportRequests',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_availability_v2_get_to_one_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_app_availabilities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appAvailabilities")] = None,
        fields_territory_availabilities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territoryAvailabilities")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_territory_availabilities: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related territoryAvailabilities returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAvailabilityV2Response:
        """apps_app_availability_v2_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_app_availabilities: the fields to include for returned resources of type appAvailabilities
        :type fields_app_availabilities: List[str]
        :param fields_territory_availabilities: the fields to include for returned resources of type territoryAvailabilities
        :type fields_territory_availabilities: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_territory_availabilities: maximum number of related territoryAvailabilities returned (when they are included)
        :type limit_territory_availabilities: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_availability_v2_get_to_one_related_serialize(
            id=id,
            fields_app_availabilities=fields_app_availabilities,
            fields_territory_availabilities=fields_territory_availabilities,
            include=include,
            limit_territory_availabilities=limit_territory_availabilities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAvailabilityV2Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_availability_v2_get_to_one_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_app_availabilities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appAvailabilities")] = None,
        fields_territory_availabilities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territoryAvailabilities")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_territory_availabilities: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related territoryAvailabilities returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAvailabilityV2Response]:
        """apps_app_availability_v2_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_app_availabilities: the fields to include for returned resources of type appAvailabilities
        :type fields_app_availabilities: List[str]
        :param fields_territory_availabilities: the fields to include for returned resources of type territoryAvailabilities
        :type fields_territory_availabilities: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_territory_availabilities: maximum number of related territoryAvailabilities returned (when they are included)
        :type limit_territory_availabilities: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_availability_v2_get_to_one_related_serialize(
            id=id,
            fields_app_availabilities=fields_app_availabilities,
            fields_territory_availabilities=fields_territory_availabilities,
            include=include,
            limit_territory_availabilities=limit_territory_availabilities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAvailabilityV2Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_availability_v2_get_to_one_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_app_availabilities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appAvailabilities")] = None,
        fields_territory_availabilities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territoryAvailabilities")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_territory_availabilities: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related territoryAvailabilities returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_availability_v2_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_app_availabilities: the fields to include for returned resources of type appAvailabilities
        :type fields_app_availabilities: List[str]
        :param fields_territory_availabilities: the fields to include for returned resources of type territoryAvailabilities
        :type fields_territory_availabilities: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_territory_availabilities: maximum number of related territoryAvailabilities returned (when they are included)
        :type limit_territory_availabilities: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_availability_v2_get_to_one_related_serialize(
            id=id,
            fields_app_availabilities=fields_app_availabilities,
            fields_territory_availabilities=fields_territory_availabilities,
            include=include,
            limit_territory_availabilities=limit_territory_availabilities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAvailabilityV2Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_availability_v2_get_to_one_related_serialize(
        self,
        id,
        fields_app_availabilities,
        fields_territory_availabilities,
        include,
        limit_territory_availabilities,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[appAvailabilities]': 'csv',
            'fields[territoryAvailabilities]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_app_availabilities is not None:
            
            _query_params.append(('fields[appAvailabilities]', fields_app_availabilities))
            
        if fields_territory_availabilities is not None:
            
            _query_params.append(('fields[territoryAvailabilities]', fields_territory_availabilities))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_territory_availabilities is not None:
            
            _query_params.append(('limit[territoryAvailabilities]', limit_territory_availabilities))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/appAvailabilityV2',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_availability_v2_get_to_one_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAppAvailabilityV2LinkageResponse:
        """apps_app_availability_v2_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_availability_v2_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppAvailabilityV2LinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_availability_v2_get_to_one_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAppAvailabilityV2LinkageResponse]:
        """apps_app_availability_v2_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_availability_v2_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppAvailabilityV2LinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_availability_v2_get_to_one_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_availability_v2_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_availability_v2_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppAvailabilityV2LinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_availability_v2_get_to_one_relationship_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/appAvailabilityV2',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_clips_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_bundle_id: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'bundleId'")] = None,
        fields_app_clips: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClips")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_clip_default_experiences: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClipDefaultExperiences")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_clip_default_experiences: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appClipDefaultExperiences returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppClipsResponse:
        """apps_app_clips_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_bundle_id: filter by attribute 'bundleId'
        :type filter_bundle_id: List[str]
        :param fields_app_clips: the fields to include for returned resources of type appClips
        :type fields_app_clips: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_clip_default_experiences: the fields to include for returned resources of type appClipDefaultExperiences
        :type fields_app_clip_default_experiences: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_clip_default_experiences: maximum number of related appClipDefaultExperiences returned (when they are included)
        :type limit_app_clip_default_experiences: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_clips_get_to_many_related_serialize(
            id=id,
            filter_bundle_id=filter_bundle_id,
            fields_app_clips=fields_app_clips,
            fields_apps=fields_apps,
            fields_app_clip_default_experiences=fields_app_clip_default_experiences,
            limit=limit,
            include=include,
            limit_app_clip_default_experiences=limit_app_clip_default_experiences,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppClipsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_clips_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_bundle_id: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'bundleId'")] = None,
        fields_app_clips: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClips")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_clip_default_experiences: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClipDefaultExperiences")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_clip_default_experiences: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appClipDefaultExperiences returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppClipsResponse]:
        """apps_app_clips_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_bundle_id: filter by attribute 'bundleId'
        :type filter_bundle_id: List[str]
        :param fields_app_clips: the fields to include for returned resources of type appClips
        :type fields_app_clips: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_clip_default_experiences: the fields to include for returned resources of type appClipDefaultExperiences
        :type fields_app_clip_default_experiences: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_clip_default_experiences: maximum number of related appClipDefaultExperiences returned (when they are included)
        :type limit_app_clip_default_experiences: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_clips_get_to_many_related_serialize(
            id=id,
            filter_bundle_id=filter_bundle_id,
            fields_app_clips=fields_app_clips,
            fields_apps=fields_apps,
            fields_app_clip_default_experiences=fields_app_clip_default_experiences,
            limit=limit,
            include=include,
            limit_app_clip_default_experiences=limit_app_clip_default_experiences,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppClipsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_clips_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_bundle_id: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'bundleId'")] = None,
        fields_app_clips: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClips")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_clip_default_experiences: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClipDefaultExperiences")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_clip_default_experiences: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appClipDefaultExperiences returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_clips_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_bundle_id: filter by attribute 'bundleId'
        :type filter_bundle_id: List[str]
        :param fields_app_clips: the fields to include for returned resources of type appClips
        :type fields_app_clips: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_clip_default_experiences: the fields to include for returned resources of type appClipDefaultExperiences
        :type fields_app_clip_default_experiences: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_clip_default_experiences: maximum number of related appClipDefaultExperiences returned (when they are included)
        :type limit_app_clip_default_experiences: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_clips_get_to_many_related_serialize(
            id=id,
            filter_bundle_id=filter_bundle_id,
            fields_app_clips=fields_app_clips,
            fields_apps=fields_apps,
            fields_app_clip_default_experiences=fields_app_clip_default_experiences,
            limit=limit,
            include=include,
            limit_app_clip_default_experiences=limit_app_clip_default_experiences,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppClipsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_clips_get_to_many_related_serialize(
        self,
        id,
        filter_bundle_id,
        fields_app_clips,
        fields_apps,
        fields_app_clip_default_experiences,
        limit,
        include,
        limit_app_clip_default_experiences,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[bundleId]': 'csv',
            'fields[appClips]': 'csv',
            'fields[apps]': 'csv',
            'fields[appClipDefaultExperiences]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_bundle_id is not None:
            
            _query_params.append(('filter[bundleId]', filter_bundle_id))
            
        if fields_app_clips is not None:
            
            _query_params.append(('fields[appClips]', fields_app_clips))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_app_clip_default_experiences is not None:
            
            _query_params.append(('fields[appClipDefaultExperiences]', fields_app_clip_default_experiences))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_app_clip_default_experiences is not None:
            
            _query_params.append(('limit[appClipDefaultExperiences]', limit_app_clip_default_experiences))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/appClips',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_clips_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAppClipsLinkagesResponse:
        """apps_app_clips_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_clips_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppClipsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_clips_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAppClipsLinkagesResponse]:
        """apps_app_clips_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_clips_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppClipsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_clips_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_clips_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_clips_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppClipsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_clips_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/appClips',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_custom_product_pages_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_visible: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'visible'")] = None,
        fields_app_custom_product_pages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPages")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_custom_product_page_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPageVersions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_custom_product_page_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appCustomProductPageVersions returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppCustomProductPagesResponse:
        """apps_app_custom_product_pages_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_visible: filter by attribute 'visible'
        :type filter_visible: List[str]
        :param fields_app_custom_product_pages: the fields to include for returned resources of type appCustomProductPages
        :type fields_app_custom_product_pages: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_custom_product_page_versions: the fields to include for returned resources of type appCustomProductPageVersions
        :type fields_app_custom_product_page_versions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_custom_product_page_versions: maximum number of related appCustomProductPageVersions returned (when they are included)
        :type limit_app_custom_product_page_versions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_custom_product_pages_get_to_many_related_serialize(
            id=id,
            filter_visible=filter_visible,
            fields_app_custom_product_pages=fields_app_custom_product_pages,
            fields_apps=fields_apps,
            fields_app_custom_product_page_versions=fields_app_custom_product_page_versions,
            limit=limit,
            include=include,
            limit_app_custom_product_page_versions=limit_app_custom_product_page_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppCustomProductPagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_custom_product_pages_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_visible: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'visible'")] = None,
        fields_app_custom_product_pages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPages")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_custom_product_page_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPageVersions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_custom_product_page_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appCustomProductPageVersions returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppCustomProductPagesResponse]:
        """apps_app_custom_product_pages_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_visible: filter by attribute 'visible'
        :type filter_visible: List[str]
        :param fields_app_custom_product_pages: the fields to include for returned resources of type appCustomProductPages
        :type fields_app_custom_product_pages: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_custom_product_page_versions: the fields to include for returned resources of type appCustomProductPageVersions
        :type fields_app_custom_product_page_versions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_custom_product_page_versions: maximum number of related appCustomProductPageVersions returned (when they are included)
        :type limit_app_custom_product_page_versions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_custom_product_pages_get_to_many_related_serialize(
            id=id,
            filter_visible=filter_visible,
            fields_app_custom_product_pages=fields_app_custom_product_pages,
            fields_apps=fields_apps,
            fields_app_custom_product_page_versions=fields_app_custom_product_page_versions,
            limit=limit,
            include=include,
            limit_app_custom_product_page_versions=limit_app_custom_product_page_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppCustomProductPagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_custom_product_pages_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_visible: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'visible'")] = None,
        fields_app_custom_product_pages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPages")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_custom_product_page_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPageVersions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_custom_product_page_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appCustomProductPageVersions returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_custom_product_pages_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_visible: filter by attribute 'visible'
        :type filter_visible: List[str]
        :param fields_app_custom_product_pages: the fields to include for returned resources of type appCustomProductPages
        :type fields_app_custom_product_pages: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_custom_product_page_versions: the fields to include for returned resources of type appCustomProductPageVersions
        :type fields_app_custom_product_page_versions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_custom_product_page_versions: maximum number of related appCustomProductPageVersions returned (when they are included)
        :type limit_app_custom_product_page_versions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_custom_product_pages_get_to_many_related_serialize(
            id=id,
            filter_visible=filter_visible,
            fields_app_custom_product_pages=fields_app_custom_product_pages,
            fields_apps=fields_apps,
            fields_app_custom_product_page_versions=fields_app_custom_product_page_versions,
            limit=limit,
            include=include,
            limit_app_custom_product_page_versions=limit_app_custom_product_page_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppCustomProductPagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_custom_product_pages_get_to_many_related_serialize(
        self,
        id,
        filter_visible,
        fields_app_custom_product_pages,
        fields_apps,
        fields_app_custom_product_page_versions,
        limit,
        include,
        limit_app_custom_product_page_versions,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[visible]': 'csv',
            'fields[appCustomProductPages]': 'csv',
            'fields[apps]': 'csv',
            'fields[appCustomProductPageVersions]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_visible is not None:
            
            _query_params.append(('filter[visible]', filter_visible))
            
        if fields_app_custom_product_pages is not None:
            
            _query_params.append(('fields[appCustomProductPages]', fields_app_custom_product_pages))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_app_custom_product_page_versions is not None:
            
            _query_params.append(('fields[appCustomProductPageVersions]', fields_app_custom_product_page_versions))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_app_custom_product_page_versions is not None:
            
            _query_params.append(('limit[appCustomProductPageVersions]', limit_app_custom_product_page_versions))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/appCustomProductPages',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_custom_product_pages_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAppCustomProductPagesLinkagesResponse:
        """apps_app_custom_product_pages_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_custom_product_pages_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppCustomProductPagesLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_custom_product_pages_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAppCustomProductPagesLinkagesResponse]:
        """apps_app_custom_product_pages_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_custom_product_pages_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppCustomProductPagesLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_custom_product_pages_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_custom_product_pages_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_custom_product_pages_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppCustomProductPagesLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_custom_product_pages_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/appCustomProductPages',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_encryption_declarations_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_builds: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'builds'")] = None,
        fields_app_encryption_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarations")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_app_encryption_declaration_documents: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarationDocuments")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_builds: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related builds returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppEncryptionDeclarationsResponse:
        """apps_app_encryption_declarations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_builds: filter by id(s) of related 'builds'
        :type filter_builds: List[str]
        :param fields_app_encryption_declarations: the fields to include for returned resources of type appEncryptionDeclarations
        :type fields_app_encryption_declarations: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_app_encryption_declaration_documents: the fields to include for returned resources of type appEncryptionDeclarationDocuments
        :type fields_app_encryption_declaration_documents: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_builds: maximum number of related builds returned (when they are included)
        :type limit_builds: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_encryption_declarations_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_builds=filter_builds,
            fields_app_encryption_declarations=fields_app_encryption_declarations,
            fields_apps=fields_apps,
            fields_builds=fields_builds,
            fields_app_encryption_declaration_documents=fields_app_encryption_declaration_documents,
            limit=limit,
            include=include,
            limit_builds=limit_builds,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppEncryptionDeclarationsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_encryption_declarations_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_builds: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'builds'")] = None,
        fields_app_encryption_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarations")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_app_encryption_declaration_documents: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarationDocuments")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_builds: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related builds returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppEncryptionDeclarationsResponse]:
        """apps_app_encryption_declarations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_builds: filter by id(s) of related 'builds'
        :type filter_builds: List[str]
        :param fields_app_encryption_declarations: the fields to include for returned resources of type appEncryptionDeclarations
        :type fields_app_encryption_declarations: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_app_encryption_declaration_documents: the fields to include for returned resources of type appEncryptionDeclarationDocuments
        :type fields_app_encryption_declaration_documents: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_builds: maximum number of related builds returned (when they are included)
        :type limit_builds: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_encryption_declarations_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_builds=filter_builds,
            fields_app_encryption_declarations=fields_app_encryption_declarations,
            fields_apps=fields_apps,
            fields_builds=fields_builds,
            fields_app_encryption_declaration_documents=fields_app_encryption_declaration_documents,
            limit=limit,
            include=include,
            limit_builds=limit_builds,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppEncryptionDeclarationsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_encryption_declarations_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_builds: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'builds'")] = None,
        fields_app_encryption_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarations")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_app_encryption_declaration_documents: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarationDocuments")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_builds: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related builds returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_encryption_declarations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_builds: filter by id(s) of related 'builds'
        :type filter_builds: List[str]
        :param fields_app_encryption_declarations: the fields to include for returned resources of type appEncryptionDeclarations
        :type fields_app_encryption_declarations: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_app_encryption_declaration_documents: the fields to include for returned resources of type appEncryptionDeclarationDocuments
        :type fields_app_encryption_declaration_documents: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_builds: maximum number of related builds returned (when they are included)
        :type limit_builds: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_encryption_declarations_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_builds=filter_builds,
            fields_app_encryption_declarations=fields_app_encryption_declarations,
            fields_apps=fields_apps,
            fields_builds=fields_builds,
            fields_app_encryption_declaration_documents=fields_app_encryption_declaration_documents,
            limit=limit,
            include=include,
            limit_builds=limit_builds,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppEncryptionDeclarationsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_encryption_declarations_get_to_many_related_serialize(
        self,
        id,
        filter_platform,
        filter_builds,
        fields_app_encryption_declarations,
        fields_apps,
        fields_builds,
        fields_app_encryption_declaration_documents,
        limit,
        include,
        limit_builds,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[platform]': 'csv',
            'filter[builds]': 'csv',
            'fields[appEncryptionDeclarations]': 'csv',
            'fields[apps]': 'csv',
            'fields[builds]': 'csv',
            'fields[appEncryptionDeclarationDocuments]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_platform is not None:
            
            _query_params.append(('filter[platform]', filter_platform))
            
        if filter_builds is not None:
            
            _query_params.append(('filter[builds]', filter_builds))
            
        if fields_app_encryption_declarations is not None:
            
            _query_params.append(('fields[appEncryptionDeclarations]', fields_app_encryption_declarations))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_builds is not None:
            
            _query_params.append(('fields[builds]', fields_builds))
            
        if fields_app_encryption_declaration_documents is not None:
            
            _query_params.append(('fields[appEncryptionDeclarationDocuments]', fields_app_encryption_declaration_documents))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_builds is not None:
            
            _query_params.append(('limit[builds]', limit_builds))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/appEncryptionDeclarations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_encryption_declarations_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAppEncryptionDeclarationsLinkagesResponse:
        """apps_app_encryption_declarations_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_encryption_declarations_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppEncryptionDeclarationsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_encryption_declarations_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAppEncryptionDeclarationsLinkagesResponse]:
        """apps_app_encryption_declarations_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_encryption_declarations_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppEncryptionDeclarationsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_encryption_declarations_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_encryption_declarations_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_encryption_declarations_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppEncryptionDeclarationsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_encryption_declarations_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/appEncryptionDeclarations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_events_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_event_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'eventState'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        fields_app_events: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEvents")] = None,
        fields_app_event_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEventLocalizations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related localizations returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppEventsResponse:
        """apps_app_events_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_event_state: filter by attribute 'eventState'
        :type filter_event_state: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param fields_app_events: the fields to include for returned resources of type appEvents
        :type fields_app_events: List[str]
        :param fields_app_event_localizations: the fields to include for returned resources of type appEventLocalizations
        :type fields_app_event_localizations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_localizations: maximum number of related localizations returned (when they are included)
        :type limit_localizations: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_events_get_to_many_related_serialize(
            id=id,
            filter_event_state=filter_event_state,
            filter_id=filter_id,
            fields_app_events=fields_app_events,
            fields_app_event_localizations=fields_app_event_localizations,
            limit=limit,
            include=include,
            limit_localizations=limit_localizations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppEventsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_events_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_event_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'eventState'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        fields_app_events: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEvents")] = None,
        fields_app_event_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEventLocalizations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related localizations returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppEventsResponse]:
        """apps_app_events_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_event_state: filter by attribute 'eventState'
        :type filter_event_state: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param fields_app_events: the fields to include for returned resources of type appEvents
        :type fields_app_events: List[str]
        :param fields_app_event_localizations: the fields to include for returned resources of type appEventLocalizations
        :type fields_app_event_localizations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_localizations: maximum number of related localizations returned (when they are included)
        :type limit_localizations: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_events_get_to_many_related_serialize(
            id=id,
            filter_event_state=filter_event_state,
            filter_id=filter_id,
            fields_app_events=fields_app_events,
            fields_app_event_localizations=fields_app_event_localizations,
            limit=limit,
            include=include,
            limit_localizations=limit_localizations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppEventsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_events_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_event_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'eventState'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        fields_app_events: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEvents")] = None,
        fields_app_event_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEventLocalizations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related localizations returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_events_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_event_state: filter by attribute 'eventState'
        :type filter_event_state: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param fields_app_events: the fields to include for returned resources of type appEvents
        :type fields_app_events: List[str]
        :param fields_app_event_localizations: the fields to include for returned resources of type appEventLocalizations
        :type fields_app_event_localizations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_localizations: maximum number of related localizations returned (when they are included)
        :type limit_localizations: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_events_get_to_many_related_serialize(
            id=id,
            filter_event_state=filter_event_state,
            filter_id=filter_id,
            fields_app_events=fields_app_events,
            fields_app_event_localizations=fields_app_event_localizations,
            limit=limit,
            include=include,
            limit_localizations=limit_localizations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppEventsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_events_get_to_many_related_serialize(
        self,
        id,
        filter_event_state,
        filter_id,
        fields_app_events,
        fields_app_event_localizations,
        limit,
        include,
        limit_localizations,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[eventState]': 'csv',
            'filter[id]': 'csv',
            'fields[appEvents]': 'csv',
            'fields[appEventLocalizations]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_event_state is not None:
            
            _query_params.append(('filter[eventState]', filter_event_state))
            
        if filter_id is not None:
            
            _query_params.append(('filter[id]', filter_id))
            
        if fields_app_events is not None:
            
            _query_params.append(('fields[appEvents]', fields_app_events))
            
        if fields_app_event_localizations is not None:
            
            _query_params.append(('fields[appEventLocalizations]', fields_app_event_localizations))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_localizations is not None:
            
            _query_params.append(('limit[localizations]', limit_localizations))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/appEvents',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_events_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAppEventsLinkagesResponse:
        """apps_app_events_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_events_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppEventsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_events_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAppEventsLinkagesResponse]:
        """apps_app_events_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_events_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppEventsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_events_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_events_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_events_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppEventsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_events_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/appEvents',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_infos_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_app_infos: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfos")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_age_rating_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ageRatingDeclarations")] = None,
        fields_app_info_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfoLocalizations")] = None,
        fields_app_categories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCategories")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_info_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appInfoLocalizations returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppInfosResponse:
        """apps_app_infos_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_app_infos: the fields to include for returned resources of type appInfos
        :type fields_app_infos: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_age_rating_declarations: the fields to include for returned resources of type ageRatingDeclarations
        :type fields_age_rating_declarations: List[str]
        :param fields_app_info_localizations: the fields to include for returned resources of type appInfoLocalizations
        :type fields_app_info_localizations: List[str]
        :param fields_app_categories: the fields to include for returned resources of type appCategories
        :type fields_app_categories: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_info_localizations: maximum number of related appInfoLocalizations returned (when they are included)
        :type limit_app_info_localizations: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_infos_get_to_many_related_serialize(
            id=id,
            fields_app_infos=fields_app_infos,
            fields_apps=fields_apps,
            fields_age_rating_declarations=fields_age_rating_declarations,
            fields_app_info_localizations=fields_app_info_localizations,
            fields_app_categories=fields_app_categories,
            limit=limit,
            include=include,
            limit_app_info_localizations=limit_app_info_localizations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppInfosResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_infos_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_app_infos: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfos")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_age_rating_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ageRatingDeclarations")] = None,
        fields_app_info_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfoLocalizations")] = None,
        fields_app_categories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCategories")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_info_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appInfoLocalizations returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppInfosResponse]:
        """apps_app_infos_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_app_infos: the fields to include for returned resources of type appInfos
        :type fields_app_infos: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_age_rating_declarations: the fields to include for returned resources of type ageRatingDeclarations
        :type fields_age_rating_declarations: List[str]
        :param fields_app_info_localizations: the fields to include for returned resources of type appInfoLocalizations
        :type fields_app_info_localizations: List[str]
        :param fields_app_categories: the fields to include for returned resources of type appCategories
        :type fields_app_categories: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_info_localizations: maximum number of related appInfoLocalizations returned (when they are included)
        :type limit_app_info_localizations: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_infos_get_to_many_related_serialize(
            id=id,
            fields_app_infos=fields_app_infos,
            fields_apps=fields_apps,
            fields_age_rating_declarations=fields_age_rating_declarations,
            fields_app_info_localizations=fields_app_info_localizations,
            fields_app_categories=fields_app_categories,
            limit=limit,
            include=include,
            limit_app_info_localizations=limit_app_info_localizations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppInfosResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_infos_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_app_infos: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfos")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_age_rating_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ageRatingDeclarations")] = None,
        fields_app_info_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfoLocalizations")] = None,
        fields_app_categories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCategories")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_info_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appInfoLocalizations returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_infos_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_app_infos: the fields to include for returned resources of type appInfos
        :type fields_app_infos: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_age_rating_declarations: the fields to include for returned resources of type ageRatingDeclarations
        :type fields_age_rating_declarations: List[str]
        :param fields_app_info_localizations: the fields to include for returned resources of type appInfoLocalizations
        :type fields_app_info_localizations: List[str]
        :param fields_app_categories: the fields to include for returned resources of type appCategories
        :type fields_app_categories: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_info_localizations: maximum number of related appInfoLocalizations returned (when they are included)
        :type limit_app_info_localizations: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_infos_get_to_many_related_serialize(
            id=id,
            fields_app_infos=fields_app_infos,
            fields_apps=fields_apps,
            fields_age_rating_declarations=fields_age_rating_declarations,
            fields_app_info_localizations=fields_app_info_localizations,
            fields_app_categories=fields_app_categories,
            limit=limit,
            include=include,
            limit_app_info_localizations=limit_app_info_localizations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppInfosResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_infos_get_to_many_related_serialize(
        self,
        id,
        fields_app_infos,
        fields_apps,
        fields_age_rating_declarations,
        fields_app_info_localizations,
        fields_app_categories,
        limit,
        include,
        limit_app_info_localizations,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[appInfos]': 'csv',
            'fields[apps]': 'csv',
            'fields[ageRatingDeclarations]': 'csv',
            'fields[appInfoLocalizations]': 'csv',
            'fields[appCategories]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_app_infos is not None:
            
            _query_params.append(('fields[appInfos]', fields_app_infos))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_age_rating_declarations is not None:
            
            _query_params.append(('fields[ageRatingDeclarations]', fields_age_rating_declarations))
            
        if fields_app_info_localizations is not None:
            
            _query_params.append(('fields[appInfoLocalizations]', fields_app_info_localizations))
            
        if fields_app_categories is not None:
            
            _query_params.append(('fields[appCategories]', fields_app_categories))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_app_info_localizations is not None:
            
            _query_params.append(('limit[appInfoLocalizations]', limit_app_info_localizations))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/appInfos',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_infos_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAppInfosLinkagesResponse:
        """apps_app_infos_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_infos_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppInfosLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_infos_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAppInfosLinkagesResponse]:
        """apps_app_infos_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_infos_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppInfosLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_infos_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_infos_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_infos_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppInfosLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_infos_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/appInfos',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_price_points_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_territory: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'territory'")] = None,
        fields_app_price_points: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appPricePoints")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_territories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territories")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppPricePointsV3Response:
        """apps_app_price_points_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_territory: filter by id(s) of related 'territory'
        :type filter_territory: List[str]
        :param fields_app_price_points: the fields to include for returned resources of type appPricePoints
        :type fields_app_price_points: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_territories: the fields to include for returned resources of type territories
        :type fields_territories: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_points_get_to_many_related_serialize(
            id=id,
            filter_territory=filter_territory,
            fields_app_price_points=fields_app_price_points,
            fields_apps=fields_apps,
            fields_territories=fields_territories,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPricePointsV3Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_price_points_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_territory: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'territory'")] = None,
        fields_app_price_points: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appPricePoints")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_territories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territories")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppPricePointsV3Response]:
        """apps_app_price_points_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_territory: filter by id(s) of related 'territory'
        :type filter_territory: List[str]
        :param fields_app_price_points: the fields to include for returned resources of type appPricePoints
        :type fields_app_price_points: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_territories: the fields to include for returned resources of type territories
        :type fields_territories: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_points_get_to_many_related_serialize(
            id=id,
            filter_territory=filter_territory,
            fields_app_price_points=fields_app_price_points,
            fields_apps=fields_apps,
            fields_territories=fields_territories,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPricePointsV3Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_price_points_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_territory: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'territory'")] = None,
        fields_app_price_points: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appPricePoints")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_territories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territories")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_price_points_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_territory: filter by id(s) of related 'territory'
        :type filter_territory: List[str]
        :param fields_app_price_points: the fields to include for returned resources of type appPricePoints
        :type fields_app_price_points: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_territories: the fields to include for returned resources of type territories
        :type fields_territories: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_points_get_to_many_related_serialize(
            id=id,
            filter_territory=filter_territory,
            fields_app_price_points=fields_app_price_points,
            fields_apps=fields_apps,
            fields_territories=fields_territories,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPricePointsV3Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_price_points_get_to_many_related_serialize(
        self,
        id,
        filter_territory,
        fields_app_price_points,
        fields_apps,
        fields_territories,
        limit,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[territory]': 'csv',
            'fields[appPricePoints]': 'csv',
            'fields[apps]': 'csv',
            'fields[territories]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_territory is not None:
            
            _query_params.append(('filter[territory]', filter_territory))
            
        if fields_app_price_points is not None:
            
            _query_params.append(('fields[appPricePoints]', fields_app_price_points))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_territories is not None:
            
            _query_params.append(('fields[territories]', fields_territories))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/csv'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/appPricePoints',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_price_points_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAppPricePointsLinkagesResponse:
        """apps_app_price_points_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_points_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppPricePointsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_price_points_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAppPricePointsLinkagesResponse]:
        """apps_app_price_points_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_points_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppPricePointsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_price_points_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_price_points_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_points_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppPricePointsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_price_points_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/appPricePoints',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_price_schedule_get_to_one_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_app_price_schedules: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appPriceSchedules")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_territories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territories")] = None,
        fields_app_prices: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appPrices")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_manual_prices: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related manualPrices returned (when they are included)")] = None,
        limit_automatic_prices: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related automaticPrices returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppPriceScheduleResponse:
        """apps_app_price_schedule_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_app_price_schedules: the fields to include for returned resources of type appPriceSchedules
        :type fields_app_price_schedules: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_territories: the fields to include for returned resources of type territories
        :type fields_territories: List[str]
        :param fields_app_prices: the fields to include for returned resources of type appPrices
        :type fields_app_prices: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_manual_prices: maximum number of related manualPrices returned (when they are included)
        :type limit_manual_prices: int
        :param limit_automatic_prices: maximum number of related automaticPrices returned (when they are included)
        :type limit_automatic_prices: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_schedule_get_to_one_related_serialize(
            id=id,
            fields_app_price_schedules=fields_app_price_schedules,
            fields_apps=fields_apps,
            fields_territories=fields_territories,
            fields_app_prices=fields_app_prices,
            include=include,
            limit_manual_prices=limit_manual_prices,
            limit_automatic_prices=limit_automatic_prices,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPriceScheduleResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_price_schedule_get_to_one_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_app_price_schedules: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appPriceSchedules")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_territories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territories")] = None,
        fields_app_prices: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appPrices")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_manual_prices: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related manualPrices returned (when they are included)")] = None,
        limit_automatic_prices: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related automaticPrices returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppPriceScheduleResponse]:
        """apps_app_price_schedule_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_app_price_schedules: the fields to include for returned resources of type appPriceSchedules
        :type fields_app_price_schedules: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_territories: the fields to include for returned resources of type territories
        :type fields_territories: List[str]
        :param fields_app_prices: the fields to include for returned resources of type appPrices
        :type fields_app_prices: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_manual_prices: maximum number of related manualPrices returned (when they are included)
        :type limit_manual_prices: int
        :param limit_automatic_prices: maximum number of related automaticPrices returned (when they are included)
        :type limit_automatic_prices: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_schedule_get_to_one_related_serialize(
            id=id,
            fields_app_price_schedules=fields_app_price_schedules,
            fields_apps=fields_apps,
            fields_territories=fields_territories,
            fields_app_prices=fields_app_prices,
            include=include,
            limit_manual_prices=limit_manual_prices,
            limit_automatic_prices=limit_automatic_prices,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPriceScheduleResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_price_schedule_get_to_one_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_app_price_schedules: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appPriceSchedules")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_territories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territories")] = None,
        fields_app_prices: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appPrices")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_manual_prices: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related manualPrices returned (when they are included)")] = None,
        limit_automatic_prices: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related automaticPrices returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_price_schedule_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_app_price_schedules: the fields to include for returned resources of type appPriceSchedules
        :type fields_app_price_schedules: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_territories: the fields to include for returned resources of type territories
        :type fields_territories: List[str]
        :param fields_app_prices: the fields to include for returned resources of type appPrices
        :type fields_app_prices: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_manual_prices: maximum number of related manualPrices returned (when they are included)
        :type limit_manual_prices: int
        :param limit_automatic_prices: maximum number of related automaticPrices returned (when they are included)
        :type limit_automatic_prices: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_schedule_get_to_one_related_serialize(
            id=id,
            fields_app_price_schedules=fields_app_price_schedules,
            fields_apps=fields_apps,
            fields_territories=fields_territories,
            fields_app_prices=fields_app_prices,
            include=include,
            limit_manual_prices=limit_manual_prices,
            limit_automatic_prices=limit_automatic_prices,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPriceScheduleResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_price_schedule_get_to_one_related_serialize(
        self,
        id,
        fields_app_price_schedules,
        fields_apps,
        fields_territories,
        fields_app_prices,
        include,
        limit_manual_prices,
        limit_automatic_prices,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[appPriceSchedules]': 'csv',
            'fields[apps]': 'csv',
            'fields[territories]': 'csv',
            'fields[appPrices]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_app_price_schedules is not None:
            
            _query_params.append(('fields[appPriceSchedules]', fields_app_price_schedules))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_territories is not None:
            
            _query_params.append(('fields[territories]', fields_territories))
            
        if fields_app_prices is not None:
            
            _query_params.append(('fields[appPrices]', fields_app_prices))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_manual_prices is not None:
            
            _query_params.append(('limit[manualPrices]', limit_manual_prices))
            
        if limit_automatic_prices is not None:
            
            _query_params.append(('limit[automaticPrices]', limit_automatic_prices))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/appPriceSchedule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_price_schedule_get_to_one_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAppPriceScheduleLinkageResponse:
        """apps_app_price_schedule_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_schedule_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppPriceScheduleLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_price_schedule_get_to_one_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAppPriceScheduleLinkageResponse]:
        """apps_app_price_schedule_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_schedule_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppPriceScheduleLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_price_schedule_get_to_one_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_price_schedule_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_price_schedule_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppPriceScheduleLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_price_schedule_get_to_one_relationship_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/appPriceSchedule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_store_version_experiments_v2_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_app_store_version_experiment_treatments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperimentTreatments")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_control_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related controlVersions returned (when they are included)")] = None,
        limit_app_store_version_experiment_treatments: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentTreatments returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppStoreVersionExperimentsV2Response:
        """apps_app_store_version_experiments_v2_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_app_store_version_experiment_treatments: the fields to include for returned resources of type appStoreVersionExperimentTreatments
        :type fields_app_store_version_experiment_treatments: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_control_versions: maximum number of related controlVersions returned (when they are included)
        :type limit_control_versions: int
        :param limit_app_store_version_experiment_treatments: maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
        :type limit_app_store_version_experiment_treatments: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_version_experiments_v2_get_to_many_related_serialize(
            id=id,
            filter_state=filter_state,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            fields_apps=fields_apps,
            fields_app_store_versions=fields_app_store_versions,
            fields_app_store_version_experiment_treatments=fields_app_store_version_experiment_treatments,
            limit=limit,
            include=include,
            limit_control_versions=limit_control_versions,
            limit_app_store_version_experiment_treatments=limit_app_store_version_experiment_treatments,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppStoreVersionExperimentsV2Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_store_version_experiments_v2_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_app_store_version_experiment_treatments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperimentTreatments")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_control_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related controlVersions returned (when they are included)")] = None,
        limit_app_store_version_experiment_treatments: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentTreatments returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppStoreVersionExperimentsV2Response]:
        """apps_app_store_version_experiments_v2_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_app_store_version_experiment_treatments: the fields to include for returned resources of type appStoreVersionExperimentTreatments
        :type fields_app_store_version_experiment_treatments: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_control_versions: maximum number of related controlVersions returned (when they are included)
        :type limit_control_versions: int
        :param limit_app_store_version_experiment_treatments: maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
        :type limit_app_store_version_experiment_treatments: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_version_experiments_v2_get_to_many_related_serialize(
            id=id,
            filter_state=filter_state,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            fields_apps=fields_apps,
            fields_app_store_versions=fields_app_store_versions,
            fields_app_store_version_experiment_treatments=fields_app_store_version_experiment_treatments,
            limit=limit,
            include=include,
            limit_control_versions=limit_control_versions,
            limit_app_store_version_experiment_treatments=limit_app_store_version_experiment_treatments,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppStoreVersionExperimentsV2Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_store_version_experiments_v2_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_app_store_version_experiment_treatments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperimentTreatments")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_control_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related controlVersions returned (when they are included)")] = None,
        limit_app_store_version_experiment_treatments: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentTreatments returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_store_version_experiments_v2_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_app_store_version_experiment_treatments: the fields to include for returned resources of type appStoreVersionExperimentTreatments
        :type fields_app_store_version_experiment_treatments: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_control_versions: maximum number of related controlVersions returned (when they are included)
        :type limit_control_versions: int
        :param limit_app_store_version_experiment_treatments: maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
        :type limit_app_store_version_experiment_treatments: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_version_experiments_v2_get_to_many_related_serialize(
            id=id,
            filter_state=filter_state,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            fields_apps=fields_apps,
            fields_app_store_versions=fields_app_store_versions,
            fields_app_store_version_experiment_treatments=fields_app_store_version_experiment_treatments,
            limit=limit,
            include=include,
            limit_control_versions=limit_control_versions,
            limit_app_store_version_experiment_treatments=limit_app_store_version_experiment_treatments,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppStoreVersionExperimentsV2Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_store_version_experiments_v2_get_to_many_related_serialize(
        self,
        id,
        filter_state,
        fields_app_store_version_experiments,
        fields_apps,
        fields_app_store_versions,
        fields_app_store_version_experiment_treatments,
        limit,
        include,
        limit_control_versions,
        limit_app_store_version_experiment_treatments,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[state]': 'csv',
            'fields[appStoreVersionExperiments]': 'csv',
            'fields[apps]': 'csv',
            'fields[appStoreVersions]': 'csv',
            'fields[appStoreVersionExperimentTreatments]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_state is not None:
            
            _query_params.append(('filter[state]', filter_state))
            
        if fields_app_store_version_experiments is not None:
            
            _query_params.append(('fields[appStoreVersionExperiments]', fields_app_store_version_experiments))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_app_store_versions is not None:
            
            _query_params.append(('fields[appStoreVersions]', fields_app_store_versions))
            
        if fields_app_store_version_experiment_treatments is not None:
            
            _query_params.append(('fields[appStoreVersionExperimentTreatments]', fields_app_store_version_experiment_treatments))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_control_versions is not None:
            
            _query_params.append(('limit[controlVersions]', limit_control_versions))
            
        if limit_app_store_version_experiment_treatments is not None:
            
            _query_params.append(('limit[appStoreVersionExperimentTreatments]', limit_app_store_version_experiment_treatments))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/appStoreVersionExperimentsV2',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_store_version_experiments_v2_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAppStoreVersionExperimentsV2LinkagesResponse:
        """apps_app_store_version_experiments_v2_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_version_experiments_v2_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppStoreVersionExperimentsV2LinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_store_version_experiments_v2_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAppStoreVersionExperimentsV2LinkagesResponse]:
        """apps_app_store_version_experiments_v2_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_version_experiments_v2_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppStoreVersionExperimentsV2LinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_store_version_experiments_v2_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_store_version_experiments_v2_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_version_experiments_v2_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppStoreVersionExperimentsV2LinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_store_version_experiments_v2_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/appStoreVersionExperimentsV2',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_store_versions_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_version_string: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'versionString'")] = None,
        filter_app_store_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreState'")] = None,
        filter_app_version_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appVersionState'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_age_rating_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ageRatingDeclarations")] = None,
        fields_app_store_version_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionLocalizations")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_app_store_version_phased_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionPhasedReleases")] = None,
        fields_game_center_app_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAppVersions")] = None,
        fields_routing_app_coverages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type routingAppCoverages")] = None,
        fields_app_store_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreReviewDetails")] = None,
        fields_app_store_version_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionSubmissions")] = None,
        fields_app_clip_default_experiences: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClipDefaultExperiences")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        fields_alternative_distribution_packages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type alternativeDistributionPackages")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_store_version_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionLocalizations returned (when they are included)")] = None,
        limit_app_store_version_experiments: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperiments returned (when they are included)")] = None,
        limit_app_store_version_experiments_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentsV2 returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppStoreVersionsResponse:
        """apps_app_store_versions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_version_string: filter by attribute 'versionString'
        :type filter_version_string: List[str]
        :param filter_app_store_state: filter by attribute 'appStoreState'
        :type filter_app_store_state: List[str]
        :param filter_app_version_state: filter by attribute 'appVersionState'
        :type filter_app_version_state: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_age_rating_declarations: the fields to include for returned resources of type ageRatingDeclarations
        :type fields_age_rating_declarations: List[str]
        :param fields_app_store_version_localizations: the fields to include for returned resources of type appStoreVersionLocalizations
        :type fields_app_store_version_localizations: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_app_store_version_phased_releases: the fields to include for returned resources of type appStoreVersionPhasedReleases
        :type fields_app_store_version_phased_releases: List[str]
        :param fields_game_center_app_versions: the fields to include for returned resources of type gameCenterAppVersions
        :type fields_game_center_app_versions: List[str]
        :param fields_routing_app_coverages: the fields to include for returned resources of type routingAppCoverages
        :type fields_routing_app_coverages: List[str]
        :param fields_app_store_review_details: the fields to include for returned resources of type appStoreReviewDetails
        :type fields_app_store_review_details: List[str]
        :param fields_app_store_version_submissions: the fields to include for returned resources of type appStoreVersionSubmissions
        :type fields_app_store_version_submissions: List[str]
        :param fields_app_clip_default_experiences: the fields to include for returned resources of type appClipDefaultExperiences
        :type fields_app_clip_default_experiences: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param fields_alternative_distribution_packages: the fields to include for returned resources of type alternativeDistributionPackages
        :type fields_alternative_distribution_packages: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_store_version_localizations: maximum number of related appStoreVersionLocalizations returned (when they are included)
        :type limit_app_store_version_localizations: int
        :param limit_app_store_version_experiments: maximum number of related appStoreVersionExperiments returned (when they are included)
        :type limit_app_store_version_experiments: int
        :param limit_app_store_version_experiments_v2: maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
        :type limit_app_store_version_experiments_v2: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_versions_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_version_string=filter_version_string,
            filter_app_store_state=filter_app_store_state,
            filter_app_version_state=filter_app_version_state,
            filter_id=filter_id,
            fields_app_store_versions=fields_app_store_versions,
            fields_apps=fields_apps,
            fields_age_rating_declarations=fields_age_rating_declarations,
            fields_app_store_version_localizations=fields_app_store_version_localizations,
            fields_builds=fields_builds,
            fields_app_store_version_phased_releases=fields_app_store_version_phased_releases,
            fields_game_center_app_versions=fields_game_center_app_versions,
            fields_routing_app_coverages=fields_routing_app_coverages,
            fields_app_store_review_details=fields_app_store_review_details,
            fields_app_store_version_submissions=fields_app_store_version_submissions,
            fields_app_clip_default_experiences=fields_app_clip_default_experiences,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            fields_alternative_distribution_packages=fields_alternative_distribution_packages,
            limit=limit,
            include=include,
            limit_app_store_version_localizations=limit_app_store_version_localizations,
            limit_app_store_version_experiments=limit_app_store_version_experiments,
            limit_app_store_version_experiments_v2=limit_app_store_version_experiments_v2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppStoreVersionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_store_versions_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_version_string: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'versionString'")] = None,
        filter_app_store_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreState'")] = None,
        filter_app_version_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appVersionState'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_age_rating_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ageRatingDeclarations")] = None,
        fields_app_store_version_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionLocalizations")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_app_store_version_phased_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionPhasedReleases")] = None,
        fields_game_center_app_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAppVersions")] = None,
        fields_routing_app_coverages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type routingAppCoverages")] = None,
        fields_app_store_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreReviewDetails")] = None,
        fields_app_store_version_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionSubmissions")] = None,
        fields_app_clip_default_experiences: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClipDefaultExperiences")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        fields_alternative_distribution_packages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type alternativeDistributionPackages")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_store_version_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionLocalizations returned (when they are included)")] = None,
        limit_app_store_version_experiments: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperiments returned (when they are included)")] = None,
        limit_app_store_version_experiments_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentsV2 returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppStoreVersionsResponse]:
        """apps_app_store_versions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_version_string: filter by attribute 'versionString'
        :type filter_version_string: List[str]
        :param filter_app_store_state: filter by attribute 'appStoreState'
        :type filter_app_store_state: List[str]
        :param filter_app_version_state: filter by attribute 'appVersionState'
        :type filter_app_version_state: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_age_rating_declarations: the fields to include for returned resources of type ageRatingDeclarations
        :type fields_age_rating_declarations: List[str]
        :param fields_app_store_version_localizations: the fields to include for returned resources of type appStoreVersionLocalizations
        :type fields_app_store_version_localizations: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_app_store_version_phased_releases: the fields to include for returned resources of type appStoreVersionPhasedReleases
        :type fields_app_store_version_phased_releases: List[str]
        :param fields_game_center_app_versions: the fields to include for returned resources of type gameCenterAppVersions
        :type fields_game_center_app_versions: List[str]
        :param fields_routing_app_coverages: the fields to include for returned resources of type routingAppCoverages
        :type fields_routing_app_coverages: List[str]
        :param fields_app_store_review_details: the fields to include for returned resources of type appStoreReviewDetails
        :type fields_app_store_review_details: List[str]
        :param fields_app_store_version_submissions: the fields to include for returned resources of type appStoreVersionSubmissions
        :type fields_app_store_version_submissions: List[str]
        :param fields_app_clip_default_experiences: the fields to include for returned resources of type appClipDefaultExperiences
        :type fields_app_clip_default_experiences: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param fields_alternative_distribution_packages: the fields to include for returned resources of type alternativeDistributionPackages
        :type fields_alternative_distribution_packages: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_store_version_localizations: maximum number of related appStoreVersionLocalizations returned (when they are included)
        :type limit_app_store_version_localizations: int
        :param limit_app_store_version_experiments: maximum number of related appStoreVersionExperiments returned (when they are included)
        :type limit_app_store_version_experiments: int
        :param limit_app_store_version_experiments_v2: maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
        :type limit_app_store_version_experiments_v2: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_versions_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_version_string=filter_version_string,
            filter_app_store_state=filter_app_store_state,
            filter_app_version_state=filter_app_version_state,
            filter_id=filter_id,
            fields_app_store_versions=fields_app_store_versions,
            fields_apps=fields_apps,
            fields_age_rating_declarations=fields_age_rating_declarations,
            fields_app_store_version_localizations=fields_app_store_version_localizations,
            fields_builds=fields_builds,
            fields_app_store_version_phased_releases=fields_app_store_version_phased_releases,
            fields_game_center_app_versions=fields_game_center_app_versions,
            fields_routing_app_coverages=fields_routing_app_coverages,
            fields_app_store_review_details=fields_app_store_review_details,
            fields_app_store_version_submissions=fields_app_store_version_submissions,
            fields_app_clip_default_experiences=fields_app_clip_default_experiences,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            fields_alternative_distribution_packages=fields_alternative_distribution_packages,
            limit=limit,
            include=include,
            limit_app_store_version_localizations=limit_app_store_version_localizations,
            limit_app_store_version_experiments=limit_app_store_version_experiments,
            limit_app_store_version_experiments_v2=limit_app_store_version_experiments_v2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppStoreVersionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_store_versions_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_version_string: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'versionString'")] = None,
        filter_app_store_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreState'")] = None,
        filter_app_version_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appVersionState'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_age_rating_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ageRatingDeclarations")] = None,
        fields_app_store_version_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionLocalizations")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_app_store_version_phased_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionPhasedReleases")] = None,
        fields_game_center_app_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAppVersions")] = None,
        fields_routing_app_coverages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type routingAppCoverages")] = None,
        fields_app_store_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreReviewDetails")] = None,
        fields_app_store_version_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionSubmissions")] = None,
        fields_app_clip_default_experiences: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClipDefaultExperiences")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        fields_alternative_distribution_packages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type alternativeDistributionPackages")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_store_version_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionLocalizations returned (when they are included)")] = None,
        limit_app_store_version_experiments: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperiments returned (when they are included)")] = None,
        limit_app_store_version_experiments_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentsV2 returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_store_versions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_version_string: filter by attribute 'versionString'
        :type filter_version_string: List[str]
        :param filter_app_store_state: filter by attribute 'appStoreState'
        :type filter_app_store_state: List[str]
        :param filter_app_version_state: filter by attribute 'appVersionState'
        :type filter_app_version_state: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_age_rating_declarations: the fields to include for returned resources of type ageRatingDeclarations
        :type fields_age_rating_declarations: List[str]
        :param fields_app_store_version_localizations: the fields to include for returned resources of type appStoreVersionLocalizations
        :type fields_app_store_version_localizations: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_app_store_version_phased_releases: the fields to include for returned resources of type appStoreVersionPhasedReleases
        :type fields_app_store_version_phased_releases: List[str]
        :param fields_game_center_app_versions: the fields to include for returned resources of type gameCenterAppVersions
        :type fields_game_center_app_versions: List[str]
        :param fields_routing_app_coverages: the fields to include for returned resources of type routingAppCoverages
        :type fields_routing_app_coverages: List[str]
        :param fields_app_store_review_details: the fields to include for returned resources of type appStoreReviewDetails
        :type fields_app_store_review_details: List[str]
        :param fields_app_store_version_submissions: the fields to include for returned resources of type appStoreVersionSubmissions
        :type fields_app_store_version_submissions: List[str]
        :param fields_app_clip_default_experiences: the fields to include for returned resources of type appClipDefaultExperiences
        :type fields_app_clip_default_experiences: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param fields_alternative_distribution_packages: the fields to include for returned resources of type alternativeDistributionPackages
        :type fields_alternative_distribution_packages: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_store_version_localizations: maximum number of related appStoreVersionLocalizations returned (when they are included)
        :type limit_app_store_version_localizations: int
        :param limit_app_store_version_experiments: maximum number of related appStoreVersionExperiments returned (when they are included)
        :type limit_app_store_version_experiments: int
        :param limit_app_store_version_experiments_v2: maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
        :type limit_app_store_version_experiments_v2: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_versions_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_version_string=filter_version_string,
            filter_app_store_state=filter_app_store_state,
            filter_app_version_state=filter_app_version_state,
            filter_id=filter_id,
            fields_app_store_versions=fields_app_store_versions,
            fields_apps=fields_apps,
            fields_age_rating_declarations=fields_age_rating_declarations,
            fields_app_store_version_localizations=fields_app_store_version_localizations,
            fields_builds=fields_builds,
            fields_app_store_version_phased_releases=fields_app_store_version_phased_releases,
            fields_game_center_app_versions=fields_game_center_app_versions,
            fields_routing_app_coverages=fields_routing_app_coverages,
            fields_app_store_review_details=fields_app_store_review_details,
            fields_app_store_version_submissions=fields_app_store_version_submissions,
            fields_app_clip_default_experiences=fields_app_clip_default_experiences,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            fields_alternative_distribution_packages=fields_alternative_distribution_packages,
            limit=limit,
            include=include,
            limit_app_store_version_localizations=limit_app_store_version_localizations,
            limit_app_store_version_experiments=limit_app_store_version_experiments,
            limit_app_store_version_experiments_v2=limit_app_store_version_experiments_v2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppStoreVersionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_store_versions_get_to_many_related_serialize(
        self,
        id,
        filter_platform,
        filter_version_string,
        filter_app_store_state,
        filter_app_version_state,
        filter_id,
        fields_app_store_versions,
        fields_apps,
        fields_age_rating_declarations,
        fields_app_store_version_localizations,
        fields_builds,
        fields_app_store_version_phased_releases,
        fields_game_center_app_versions,
        fields_routing_app_coverages,
        fields_app_store_review_details,
        fields_app_store_version_submissions,
        fields_app_clip_default_experiences,
        fields_app_store_version_experiments,
        fields_alternative_distribution_packages,
        limit,
        include,
        limit_app_store_version_localizations,
        limit_app_store_version_experiments,
        limit_app_store_version_experiments_v2,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[platform]': 'csv',
            'filter[versionString]': 'csv',
            'filter[appStoreState]': 'csv',
            'filter[appVersionState]': 'csv',
            'filter[id]': 'csv',
            'fields[appStoreVersions]': 'csv',
            'fields[apps]': 'csv',
            'fields[ageRatingDeclarations]': 'csv',
            'fields[appStoreVersionLocalizations]': 'csv',
            'fields[builds]': 'csv',
            'fields[appStoreVersionPhasedReleases]': 'csv',
            'fields[gameCenterAppVersions]': 'csv',
            'fields[routingAppCoverages]': 'csv',
            'fields[appStoreReviewDetails]': 'csv',
            'fields[appStoreVersionSubmissions]': 'csv',
            'fields[appClipDefaultExperiences]': 'csv',
            'fields[appStoreVersionExperiments]': 'csv',
            'fields[alternativeDistributionPackages]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_platform is not None:
            
            _query_params.append(('filter[platform]', filter_platform))
            
        if filter_version_string is not None:
            
            _query_params.append(('filter[versionString]', filter_version_string))
            
        if filter_app_store_state is not None:
            
            _query_params.append(('filter[appStoreState]', filter_app_store_state))
            
        if filter_app_version_state is not None:
            
            _query_params.append(('filter[appVersionState]', filter_app_version_state))
            
        if filter_id is not None:
            
            _query_params.append(('filter[id]', filter_id))
            
        if fields_app_store_versions is not None:
            
            _query_params.append(('fields[appStoreVersions]', fields_app_store_versions))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_age_rating_declarations is not None:
            
            _query_params.append(('fields[ageRatingDeclarations]', fields_age_rating_declarations))
            
        if fields_app_store_version_localizations is not None:
            
            _query_params.append(('fields[appStoreVersionLocalizations]', fields_app_store_version_localizations))
            
        if fields_builds is not None:
            
            _query_params.append(('fields[builds]', fields_builds))
            
        if fields_app_store_version_phased_releases is not None:
            
            _query_params.append(('fields[appStoreVersionPhasedReleases]', fields_app_store_version_phased_releases))
            
        if fields_game_center_app_versions is not None:
            
            _query_params.append(('fields[gameCenterAppVersions]', fields_game_center_app_versions))
            
        if fields_routing_app_coverages is not None:
            
            _query_params.append(('fields[routingAppCoverages]', fields_routing_app_coverages))
            
        if fields_app_store_review_details is not None:
            
            _query_params.append(('fields[appStoreReviewDetails]', fields_app_store_review_details))
            
        if fields_app_store_version_submissions is not None:
            
            _query_params.append(('fields[appStoreVersionSubmissions]', fields_app_store_version_submissions))
            
        if fields_app_clip_default_experiences is not None:
            
            _query_params.append(('fields[appClipDefaultExperiences]', fields_app_clip_default_experiences))
            
        if fields_app_store_version_experiments is not None:
            
            _query_params.append(('fields[appStoreVersionExperiments]', fields_app_store_version_experiments))
            
        if fields_alternative_distribution_packages is not None:
            
            _query_params.append(('fields[alternativeDistributionPackages]', fields_alternative_distribution_packages))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_app_store_version_localizations is not None:
            
            _query_params.append(('limit[appStoreVersionLocalizations]', limit_app_store_version_localizations))
            
        if limit_app_store_version_experiments is not None:
            
            _query_params.append(('limit[appStoreVersionExperiments]', limit_app_store_version_experiments))
            
        if limit_app_store_version_experiments_v2 is not None:
            
            _query_params.append(('limit[appStoreVersionExperimentsV2]', limit_app_store_version_experiments_v2))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/appStoreVersions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_app_store_versions_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppAppStoreVersionsLinkagesResponse:
        """apps_app_store_versions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_versions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppStoreVersionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_app_store_versions_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppAppStoreVersionsLinkagesResponse]:
        """apps_app_store_versions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_versions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppStoreVersionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_app_store_versions_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_app_store_versions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_app_store_versions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppAppStoreVersionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_app_store_versions_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/appStoreVersions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_background_assets_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_asset_pack_identifier: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'assetPackIdentifier'")] = None,
        fields_background_assets: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type backgroundAssets")] = None,
        fields_background_asset_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type backgroundAssetVersions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BackgroundAssetsResponse:
        """apps_background_assets_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_asset_pack_identifier: filter by attribute 'assetPackIdentifier'
        :type filter_asset_pack_identifier: List[str]
        :param fields_background_assets: the fields to include for returned resources of type backgroundAssets
        :type fields_background_assets: List[str]
        :param fields_background_asset_versions: the fields to include for returned resources of type backgroundAssetVersions
        :type fields_background_asset_versions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_background_assets_get_to_many_related_serialize(
            id=id,
            filter_asset_pack_identifier=filter_asset_pack_identifier,
            fields_background_assets=fields_background_assets,
            fields_background_asset_versions=fields_background_asset_versions,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BackgroundAssetsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_background_assets_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_asset_pack_identifier: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'assetPackIdentifier'")] = None,
        fields_background_assets: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type backgroundAssets")] = None,
        fields_background_asset_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type backgroundAssetVersions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BackgroundAssetsResponse]:
        """apps_background_assets_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_asset_pack_identifier: filter by attribute 'assetPackIdentifier'
        :type filter_asset_pack_identifier: List[str]
        :param fields_background_assets: the fields to include for returned resources of type backgroundAssets
        :type fields_background_assets: List[str]
        :param fields_background_asset_versions: the fields to include for returned resources of type backgroundAssetVersions
        :type fields_background_asset_versions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_background_assets_get_to_many_related_serialize(
            id=id,
            filter_asset_pack_identifier=filter_asset_pack_identifier,
            fields_background_assets=fields_background_assets,
            fields_background_asset_versions=fields_background_asset_versions,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BackgroundAssetsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_background_assets_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_asset_pack_identifier: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'assetPackIdentifier'")] = None,
        fields_background_assets: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type backgroundAssets")] = None,
        fields_background_asset_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type backgroundAssetVersions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_background_assets_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_asset_pack_identifier: filter by attribute 'assetPackIdentifier'
        :type filter_asset_pack_identifier: List[str]
        :param fields_background_assets: the fields to include for returned resources of type backgroundAssets
        :type fields_background_assets: List[str]
        :param fields_background_asset_versions: the fields to include for returned resources of type backgroundAssetVersions
        :type fields_background_asset_versions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_background_assets_get_to_many_related_serialize(
            id=id,
            filter_asset_pack_identifier=filter_asset_pack_identifier,
            fields_background_assets=fields_background_assets,
            fields_background_asset_versions=fields_background_asset_versions,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BackgroundAssetsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_background_assets_get_to_many_related_serialize(
        self,
        id,
        filter_asset_pack_identifier,
        fields_background_assets,
        fields_background_asset_versions,
        limit,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[assetPackIdentifier]': 'csv',
            'fields[backgroundAssets]': 'csv',
            'fields[backgroundAssetVersions]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_asset_pack_identifier is not None:
            
            _query_params.append(('filter[assetPackIdentifier]', filter_asset_pack_identifier))
            
        if fields_background_assets is not None:
            
            _query_params.append(('fields[backgroundAssets]', fields_background_assets))
            
        if fields_background_asset_versions is not None:
            
            _query_params.append(('fields[backgroundAssetVersions]', fields_background_asset_versions))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/backgroundAssets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_background_assets_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppBackgroundAssetsLinkagesResponse:
        """apps_background_assets_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_background_assets_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBackgroundAssetsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_background_assets_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppBackgroundAssetsLinkagesResponse]:
        """apps_background_assets_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_background_assets_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBackgroundAssetsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_background_assets_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_background_assets_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_background_assets_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBackgroundAssetsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_background_assets_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/backgroundAssets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_app_localizations_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_app_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppLocalizations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BetaAppLocalizationsWithoutIncludesResponse:
        """apps_beta_app_localizations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_app_localizations: the fields to include for returned resources of type betaAppLocalizations
        :type fields_beta_app_localizations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_localizations_get_to_many_related_serialize(
            id=id,
            fields_beta_app_localizations=fields_beta_app_localizations,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaAppLocalizationsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_app_localizations_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_app_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppLocalizations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BetaAppLocalizationsWithoutIncludesResponse]:
        """apps_beta_app_localizations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_app_localizations: the fields to include for returned resources of type betaAppLocalizations
        :type fields_beta_app_localizations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_localizations_get_to_many_related_serialize(
            id=id,
            fields_beta_app_localizations=fields_beta_app_localizations,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaAppLocalizationsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_app_localizations_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_app_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppLocalizations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_app_localizations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_app_localizations: the fields to include for returned resources of type betaAppLocalizations
        :type fields_beta_app_localizations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_localizations_get_to_many_related_serialize(
            id=id,
            fields_beta_app_localizations=fields_beta_app_localizations,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaAppLocalizationsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_app_localizations_get_to_many_related_serialize(
        self,
        id,
        fields_beta_app_localizations,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[betaAppLocalizations]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_beta_app_localizations is not None:
            
            _query_params.append(('fields[betaAppLocalizations]', fields_beta_app_localizations))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/betaAppLocalizations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_app_localizations_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppBetaAppLocalizationsLinkagesResponse:
        """apps_beta_app_localizations_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_localizations_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaAppLocalizationsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_app_localizations_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppBetaAppLocalizationsLinkagesResponse]:
        """apps_beta_app_localizations_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_localizations_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaAppLocalizationsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_app_localizations_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_app_localizations_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_localizations_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaAppLocalizationsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_app_localizations_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/betaAppLocalizations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_app_review_detail_get_to_one_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_app_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppReviewDetails")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BetaAppReviewDetailWithoutIncludesResponse:
        """apps_beta_app_review_detail_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_app_review_details: the fields to include for returned resources of type betaAppReviewDetails
        :type fields_beta_app_review_details: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_review_detail_get_to_one_related_serialize(
            id=id,
            fields_beta_app_review_details=fields_beta_app_review_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaAppReviewDetailWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_app_review_detail_get_to_one_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_app_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppReviewDetails")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BetaAppReviewDetailWithoutIncludesResponse]:
        """apps_beta_app_review_detail_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_app_review_details: the fields to include for returned resources of type betaAppReviewDetails
        :type fields_beta_app_review_details: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_review_detail_get_to_one_related_serialize(
            id=id,
            fields_beta_app_review_details=fields_beta_app_review_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaAppReviewDetailWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_app_review_detail_get_to_one_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_app_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppReviewDetails")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_app_review_detail_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_app_review_details: the fields to include for returned resources of type betaAppReviewDetails
        :type fields_beta_app_review_details: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_review_detail_get_to_one_related_serialize(
            id=id,
            fields_beta_app_review_details=fields_beta_app_review_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaAppReviewDetailWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_app_review_detail_get_to_one_related_serialize(
        self,
        id,
        fields_beta_app_review_details,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[betaAppReviewDetails]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_beta_app_review_details is not None:
            
            _query_params.append(('fields[betaAppReviewDetails]', fields_beta_app_review_details))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/betaAppReviewDetail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_app_review_detail_get_to_one_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppBetaAppReviewDetailLinkageResponse:
        """apps_beta_app_review_detail_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_review_detail_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaAppReviewDetailLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_app_review_detail_get_to_one_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppBetaAppReviewDetailLinkageResponse]:
        """apps_beta_app_review_detail_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_review_detail_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaAppReviewDetailLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_app_review_detail_get_to_one_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_app_review_detail_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_app_review_detail_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaAppReviewDetailLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_app_review_detail_get_to_one_relationship_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/betaAppReviewDetail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_feedback_crash_submissions_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_device_model: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceModel'")] = None,
        filter_os_version: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'osVersion'")] = None,
        filter_app_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appPlatform'")] = None,
        filter_device_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'devicePlatform'")] = None,
        filter_build: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build'")] = None,
        filter_build_pre_release_version: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build.preReleaseVersion'")] = None,
        filter_tester: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'tester'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_beta_feedback_crash_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaFeedbackCrashSubmissions")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_testers: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaTesters")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BetaFeedbackCrashSubmissionsResponse:
        """apps_beta_feedback_crash_submissions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_device_model: filter by attribute 'deviceModel'
        :type filter_device_model: List[str]
        :param filter_os_version: filter by attribute 'osVersion'
        :type filter_os_version: List[str]
        :param filter_app_platform: filter by attribute 'appPlatform'
        :type filter_app_platform: List[str]
        :param filter_device_platform: filter by attribute 'devicePlatform'
        :type filter_device_platform: List[str]
        :param filter_build: filter by id(s) of related 'build'
        :type filter_build: List[str]
        :param filter_build_pre_release_version: filter by id(s) of related 'build.preReleaseVersion'
        :type filter_build_pre_release_version: List[str]
        :param filter_tester: filter by id(s) of related 'tester'
        :type filter_tester: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_beta_feedback_crash_submissions: the fields to include for returned resources of type betaFeedbackCrashSubmissions
        :type fields_beta_feedback_crash_submissions: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_testers: the fields to include for returned resources of type betaTesters
        :type fields_beta_testers: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_crash_submissions_get_to_many_related_serialize(
            id=id,
            filter_device_model=filter_device_model,
            filter_os_version=filter_os_version,
            filter_app_platform=filter_app_platform,
            filter_device_platform=filter_device_platform,
            filter_build=filter_build,
            filter_build_pre_release_version=filter_build_pre_release_version,
            filter_tester=filter_tester,
            sort=sort,
            fields_beta_feedback_crash_submissions=fields_beta_feedback_crash_submissions,
            fields_builds=fields_builds,
            fields_beta_testers=fields_beta_testers,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaFeedbackCrashSubmissionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_feedback_crash_submissions_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_device_model: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceModel'")] = None,
        filter_os_version: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'osVersion'")] = None,
        filter_app_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appPlatform'")] = None,
        filter_device_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'devicePlatform'")] = None,
        filter_build: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build'")] = None,
        filter_build_pre_release_version: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build.preReleaseVersion'")] = None,
        filter_tester: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'tester'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_beta_feedback_crash_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaFeedbackCrashSubmissions")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_testers: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaTesters")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BetaFeedbackCrashSubmissionsResponse]:
        """apps_beta_feedback_crash_submissions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_device_model: filter by attribute 'deviceModel'
        :type filter_device_model: List[str]
        :param filter_os_version: filter by attribute 'osVersion'
        :type filter_os_version: List[str]
        :param filter_app_platform: filter by attribute 'appPlatform'
        :type filter_app_platform: List[str]
        :param filter_device_platform: filter by attribute 'devicePlatform'
        :type filter_device_platform: List[str]
        :param filter_build: filter by id(s) of related 'build'
        :type filter_build: List[str]
        :param filter_build_pre_release_version: filter by id(s) of related 'build.preReleaseVersion'
        :type filter_build_pre_release_version: List[str]
        :param filter_tester: filter by id(s) of related 'tester'
        :type filter_tester: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_beta_feedback_crash_submissions: the fields to include for returned resources of type betaFeedbackCrashSubmissions
        :type fields_beta_feedback_crash_submissions: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_testers: the fields to include for returned resources of type betaTesters
        :type fields_beta_testers: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_crash_submissions_get_to_many_related_serialize(
            id=id,
            filter_device_model=filter_device_model,
            filter_os_version=filter_os_version,
            filter_app_platform=filter_app_platform,
            filter_device_platform=filter_device_platform,
            filter_build=filter_build,
            filter_build_pre_release_version=filter_build_pre_release_version,
            filter_tester=filter_tester,
            sort=sort,
            fields_beta_feedback_crash_submissions=fields_beta_feedback_crash_submissions,
            fields_builds=fields_builds,
            fields_beta_testers=fields_beta_testers,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaFeedbackCrashSubmissionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_feedback_crash_submissions_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_device_model: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceModel'")] = None,
        filter_os_version: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'osVersion'")] = None,
        filter_app_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appPlatform'")] = None,
        filter_device_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'devicePlatform'")] = None,
        filter_build: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build'")] = None,
        filter_build_pre_release_version: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build.preReleaseVersion'")] = None,
        filter_tester: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'tester'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_beta_feedback_crash_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaFeedbackCrashSubmissions")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_testers: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaTesters")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_feedback_crash_submissions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_device_model: filter by attribute 'deviceModel'
        :type filter_device_model: List[str]
        :param filter_os_version: filter by attribute 'osVersion'
        :type filter_os_version: List[str]
        :param filter_app_platform: filter by attribute 'appPlatform'
        :type filter_app_platform: List[str]
        :param filter_device_platform: filter by attribute 'devicePlatform'
        :type filter_device_platform: List[str]
        :param filter_build: filter by id(s) of related 'build'
        :type filter_build: List[str]
        :param filter_build_pre_release_version: filter by id(s) of related 'build.preReleaseVersion'
        :type filter_build_pre_release_version: List[str]
        :param filter_tester: filter by id(s) of related 'tester'
        :type filter_tester: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_beta_feedback_crash_submissions: the fields to include for returned resources of type betaFeedbackCrashSubmissions
        :type fields_beta_feedback_crash_submissions: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_testers: the fields to include for returned resources of type betaTesters
        :type fields_beta_testers: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_crash_submissions_get_to_many_related_serialize(
            id=id,
            filter_device_model=filter_device_model,
            filter_os_version=filter_os_version,
            filter_app_platform=filter_app_platform,
            filter_device_platform=filter_device_platform,
            filter_build=filter_build,
            filter_build_pre_release_version=filter_build_pre_release_version,
            filter_tester=filter_tester,
            sort=sort,
            fields_beta_feedback_crash_submissions=fields_beta_feedback_crash_submissions,
            fields_builds=fields_builds,
            fields_beta_testers=fields_beta_testers,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaFeedbackCrashSubmissionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_feedback_crash_submissions_get_to_many_related_serialize(
        self,
        id,
        filter_device_model,
        filter_os_version,
        filter_app_platform,
        filter_device_platform,
        filter_build,
        filter_build_pre_release_version,
        filter_tester,
        sort,
        fields_beta_feedback_crash_submissions,
        fields_builds,
        fields_beta_testers,
        limit,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[deviceModel]': 'csv',
            'filter[osVersion]': 'csv',
            'filter[appPlatform]': 'csv',
            'filter[devicePlatform]': 'csv',
            'filter[build]': 'csv',
            'filter[build.preReleaseVersion]': 'csv',
            'filter[tester]': 'csv',
            'sort': 'csv',
            'fields[betaFeedbackCrashSubmissions]': 'csv',
            'fields[builds]': 'csv',
            'fields[betaTesters]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_device_model is not None:
            
            _query_params.append(('filter[deviceModel]', filter_device_model))
            
        if filter_os_version is not None:
            
            _query_params.append(('filter[osVersion]', filter_os_version))
            
        if filter_app_platform is not None:
            
            _query_params.append(('filter[appPlatform]', filter_app_platform))
            
        if filter_device_platform is not None:
            
            _query_params.append(('filter[devicePlatform]', filter_device_platform))
            
        if filter_build is not None:
            
            _query_params.append(('filter[build]', filter_build))
            
        if filter_build_pre_release_version is not None:
            
            _query_params.append(('filter[build.preReleaseVersion]', filter_build_pre_release_version))
            
        if filter_tester is not None:
            
            _query_params.append(('filter[tester]', filter_tester))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if fields_beta_feedback_crash_submissions is not None:
            
            _query_params.append(('fields[betaFeedbackCrashSubmissions]', fields_beta_feedback_crash_submissions))
            
        if fields_builds is not None:
            
            _query_params.append(('fields[builds]', fields_builds))
            
        if fields_beta_testers is not None:
            
            _query_params.append(('fields[betaTesters]', fields_beta_testers))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/betaFeedbackCrashSubmissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_feedback_crash_submissions_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppBetaFeedbackCrashSubmissionsLinkagesResponse:
        """apps_beta_feedback_crash_submissions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_crash_submissions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaFeedbackCrashSubmissionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_feedback_crash_submissions_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppBetaFeedbackCrashSubmissionsLinkagesResponse]:
        """apps_beta_feedback_crash_submissions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_crash_submissions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaFeedbackCrashSubmissionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_feedback_crash_submissions_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_feedback_crash_submissions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_crash_submissions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaFeedbackCrashSubmissionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_feedback_crash_submissions_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/betaFeedbackCrashSubmissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_feedback_screenshot_submissions_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_device_model: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceModel'")] = None,
        filter_os_version: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'osVersion'")] = None,
        filter_app_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appPlatform'")] = None,
        filter_device_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'devicePlatform'")] = None,
        filter_build: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build'")] = None,
        filter_build_pre_release_version: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build.preReleaseVersion'")] = None,
        filter_tester: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'tester'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_beta_feedback_screenshot_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaFeedbackScreenshotSubmissions")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_testers: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaTesters")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BetaFeedbackScreenshotSubmissionsResponse:
        """apps_beta_feedback_screenshot_submissions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_device_model: filter by attribute 'deviceModel'
        :type filter_device_model: List[str]
        :param filter_os_version: filter by attribute 'osVersion'
        :type filter_os_version: List[str]
        :param filter_app_platform: filter by attribute 'appPlatform'
        :type filter_app_platform: List[str]
        :param filter_device_platform: filter by attribute 'devicePlatform'
        :type filter_device_platform: List[str]
        :param filter_build: filter by id(s) of related 'build'
        :type filter_build: List[str]
        :param filter_build_pre_release_version: filter by id(s) of related 'build.preReleaseVersion'
        :type filter_build_pre_release_version: List[str]
        :param filter_tester: filter by id(s) of related 'tester'
        :type filter_tester: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_beta_feedback_screenshot_submissions: the fields to include for returned resources of type betaFeedbackScreenshotSubmissions
        :type fields_beta_feedback_screenshot_submissions: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_testers: the fields to include for returned resources of type betaTesters
        :type fields_beta_testers: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_screenshot_submissions_get_to_many_related_serialize(
            id=id,
            filter_device_model=filter_device_model,
            filter_os_version=filter_os_version,
            filter_app_platform=filter_app_platform,
            filter_device_platform=filter_device_platform,
            filter_build=filter_build,
            filter_build_pre_release_version=filter_build_pre_release_version,
            filter_tester=filter_tester,
            sort=sort,
            fields_beta_feedback_screenshot_submissions=fields_beta_feedback_screenshot_submissions,
            fields_builds=fields_builds,
            fields_beta_testers=fields_beta_testers,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaFeedbackScreenshotSubmissionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_feedback_screenshot_submissions_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_device_model: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceModel'")] = None,
        filter_os_version: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'osVersion'")] = None,
        filter_app_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appPlatform'")] = None,
        filter_device_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'devicePlatform'")] = None,
        filter_build: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build'")] = None,
        filter_build_pre_release_version: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build.preReleaseVersion'")] = None,
        filter_tester: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'tester'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_beta_feedback_screenshot_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaFeedbackScreenshotSubmissions")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_testers: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaTesters")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BetaFeedbackScreenshotSubmissionsResponse]:
        """apps_beta_feedback_screenshot_submissions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_device_model: filter by attribute 'deviceModel'
        :type filter_device_model: List[str]
        :param filter_os_version: filter by attribute 'osVersion'
        :type filter_os_version: List[str]
        :param filter_app_platform: filter by attribute 'appPlatform'
        :type filter_app_platform: List[str]
        :param filter_device_platform: filter by attribute 'devicePlatform'
        :type filter_device_platform: List[str]
        :param filter_build: filter by id(s) of related 'build'
        :type filter_build: List[str]
        :param filter_build_pre_release_version: filter by id(s) of related 'build.preReleaseVersion'
        :type filter_build_pre_release_version: List[str]
        :param filter_tester: filter by id(s) of related 'tester'
        :type filter_tester: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_beta_feedback_screenshot_submissions: the fields to include for returned resources of type betaFeedbackScreenshotSubmissions
        :type fields_beta_feedback_screenshot_submissions: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_testers: the fields to include for returned resources of type betaTesters
        :type fields_beta_testers: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_screenshot_submissions_get_to_many_related_serialize(
            id=id,
            filter_device_model=filter_device_model,
            filter_os_version=filter_os_version,
            filter_app_platform=filter_app_platform,
            filter_device_platform=filter_device_platform,
            filter_build=filter_build,
            filter_build_pre_release_version=filter_build_pre_release_version,
            filter_tester=filter_tester,
            sort=sort,
            fields_beta_feedback_screenshot_submissions=fields_beta_feedback_screenshot_submissions,
            fields_builds=fields_builds,
            fields_beta_testers=fields_beta_testers,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaFeedbackScreenshotSubmissionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_feedback_screenshot_submissions_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_device_model: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceModel'")] = None,
        filter_os_version: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'osVersion'")] = None,
        filter_app_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appPlatform'")] = None,
        filter_device_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'devicePlatform'")] = None,
        filter_build: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build'")] = None,
        filter_build_pre_release_version: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'build.preReleaseVersion'")] = None,
        filter_tester: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'tester'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_beta_feedback_screenshot_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaFeedbackScreenshotSubmissions")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_testers: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaTesters")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_feedback_screenshot_submissions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_device_model: filter by attribute 'deviceModel'
        :type filter_device_model: List[str]
        :param filter_os_version: filter by attribute 'osVersion'
        :type filter_os_version: List[str]
        :param filter_app_platform: filter by attribute 'appPlatform'
        :type filter_app_platform: List[str]
        :param filter_device_platform: filter by attribute 'devicePlatform'
        :type filter_device_platform: List[str]
        :param filter_build: filter by id(s) of related 'build'
        :type filter_build: List[str]
        :param filter_build_pre_release_version: filter by id(s) of related 'build.preReleaseVersion'
        :type filter_build_pre_release_version: List[str]
        :param filter_tester: filter by id(s) of related 'tester'
        :type filter_tester: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_beta_feedback_screenshot_submissions: the fields to include for returned resources of type betaFeedbackScreenshotSubmissions
        :type fields_beta_feedback_screenshot_submissions: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_testers: the fields to include for returned resources of type betaTesters
        :type fields_beta_testers: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_screenshot_submissions_get_to_many_related_serialize(
            id=id,
            filter_device_model=filter_device_model,
            filter_os_version=filter_os_version,
            filter_app_platform=filter_app_platform,
            filter_device_platform=filter_device_platform,
            filter_build=filter_build,
            filter_build_pre_release_version=filter_build_pre_release_version,
            filter_tester=filter_tester,
            sort=sort,
            fields_beta_feedback_screenshot_submissions=fields_beta_feedback_screenshot_submissions,
            fields_builds=fields_builds,
            fields_beta_testers=fields_beta_testers,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaFeedbackScreenshotSubmissionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_feedback_screenshot_submissions_get_to_many_related_serialize(
        self,
        id,
        filter_device_model,
        filter_os_version,
        filter_app_platform,
        filter_device_platform,
        filter_build,
        filter_build_pre_release_version,
        filter_tester,
        sort,
        fields_beta_feedback_screenshot_submissions,
        fields_builds,
        fields_beta_testers,
        limit,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[deviceModel]': 'csv',
            'filter[osVersion]': 'csv',
            'filter[appPlatform]': 'csv',
            'filter[devicePlatform]': 'csv',
            'filter[build]': 'csv',
            'filter[build.preReleaseVersion]': 'csv',
            'filter[tester]': 'csv',
            'sort': 'csv',
            'fields[betaFeedbackScreenshotSubmissions]': 'csv',
            'fields[builds]': 'csv',
            'fields[betaTesters]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_device_model is not None:
            
            _query_params.append(('filter[deviceModel]', filter_device_model))
            
        if filter_os_version is not None:
            
            _query_params.append(('filter[osVersion]', filter_os_version))
            
        if filter_app_platform is not None:
            
            _query_params.append(('filter[appPlatform]', filter_app_platform))
            
        if filter_device_platform is not None:
            
            _query_params.append(('filter[devicePlatform]', filter_device_platform))
            
        if filter_build is not None:
            
            _query_params.append(('filter[build]', filter_build))
            
        if filter_build_pre_release_version is not None:
            
            _query_params.append(('filter[build.preReleaseVersion]', filter_build_pre_release_version))
            
        if filter_tester is not None:
            
            _query_params.append(('filter[tester]', filter_tester))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if fields_beta_feedback_screenshot_submissions is not None:
            
            _query_params.append(('fields[betaFeedbackScreenshotSubmissions]', fields_beta_feedback_screenshot_submissions))
            
        if fields_builds is not None:
            
            _query_params.append(('fields[builds]', fields_builds))
            
        if fields_beta_testers is not None:
            
            _query_params.append(('fields[betaTesters]', fields_beta_testers))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/betaFeedbackScreenshotSubmissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_feedback_screenshot_submissions_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppBetaFeedbackScreenshotSubmissionsLinkagesResponse:
        """apps_beta_feedback_screenshot_submissions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_screenshot_submissions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaFeedbackScreenshotSubmissionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_feedback_screenshot_submissions_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppBetaFeedbackScreenshotSubmissionsLinkagesResponse]:
        """apps_beta_feedback_screenshot_submissions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_screenshot_submissions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaFeedbackScreenshotSubmissionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_feedback_screenshot_submissions_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_feedback_screenshot_submissions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_feedback_screenshot_submissions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaFeedbackScreenshotSubmissionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_feedback_screenshot_submissions_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/betaFeedbackScreenshotSubmissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_groups_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaGroups")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BetaGroupsWithoutIncludesResponse:
        """apps_beta_groups_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_groups: the fields to include for returned resources of type betaGroups
        :type fields_beta_groups: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_groups_get_to_many_related_serialize(
            id=id,
            fields_beta_groups=fields_beta_groups,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaGroupsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_groups_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaGroups")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BetaGroupsWithoutIncludesResponse]:
        """apps_beta_groups_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_groups: the fields to include for returned resources of type betaGroups
        :type fields_beta_groups: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_groups_get_to_many_related_serialize(
            id=id,
            fields_beta_groups=fields_beta_groups,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaGroupsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_groups_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaGroups")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_groups_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_groups: the fields to include for returned resources of type betaGroups
        :type fields_beta_groups: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_groups_get_to_many_related_serialize(
            id=id,
            fields_beta_groups=fields_beta_groups,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaGroupsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_groups_get_to_many_related_serialize(
        self,
        id,
        fields_beta_groups,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[betaGroups]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_beta_groups is not None:
            
            _query_params.append(('fields[betaGroups]', fields_beta_groups))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/betaGroups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_groups_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppBetaGroupsLinkagesResponse:
        """apps_beta_groups_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_groups_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaGroupsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_groups_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppBetaGroupsLinkagesResponse]:
        """apps_beta_groups_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_groups_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaGroupsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_groups_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_groups_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_groups_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaGroupsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_groups_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/betaGroups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_license_agreement_get_to_one_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaLicenseAgreements")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BetaLicenseAgreementWithoutIncludesResponse:
        """apps_beta_license_agreement_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_license_agreements: the fields to include for returned resources of type betaLicenseAgreements
        :type fields_beta_license_agreements: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_license_agreement_get_to_one_related_serialize(
            id=id,
            fields_beta_license_agreements=fields_beta_license_agreements,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaLicenseAgreementWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_license_agreement_get_to_one_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaLicenseAgreements")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BetaLicenseAgreementWithoutIncludesResponse]:
        """apps_beta_license_agreement_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_license_agreements: the fields to include for returned resources of type betaLicenseAgreements
        :type fields_beta_license_agreements: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_license_agreement_get_to_one_related_serialize(
            id=id,
            fields_beta_license_agreements=fields_beta_license_agreements,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaLicenseAgreementWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_license_agreement_get_to_one_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_beta_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaLicenseAgreements")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_license_agreement_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_beta_license_agreements: the fields to include for returned resources of type betaLicenseAgreements
        :type fields_beta_license_agreements: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_license_agreement_get_to_one_related_serialize(
            id=id,
            fields_beta_license_agreements=fields_beta_license_agreements,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BetaLicenseAgreementWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_license_agreement_get_to_one_related_serialize(
        self,
        id,
        fields_beta_license_agreements,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[betaLicenseAgreements]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_beta_license_agreements is not None:
            
            _query_params.append(('fields[betaLicenseAgreements]', fields_beta_license_agreements))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/betaLicenseAgreement',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_license_agreement_get_to_one_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppBetaLicenseAgreementLinkageResponse:
        """apps_beta_license_agreement_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_license_agreement_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaLicenseAgreementLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_license_agreement_get_to_one_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppBetaLicenseAgreementLinkageResponse]:
        """apps_beta_license_agreement_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_license_agreement_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaLicenseAgreementLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_license_agreement_get_to_one_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_license_agreement_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_license_agreement_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBetaLicenseAgreementLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_license_agreement_get_to_one_relationship_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/betaLicenseAgreement',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_tester_usages_get_metrics(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        period: Annotated[Optional[StrictStr], Field(description="the duration of the reporting period")] = None,
        group_by: Annotated[Optional[List[StrictStr]], Field(description="the dimension by which to group the results")] = None,
        filter_beta_testers: Annotated[Optional[StrictStr], Field(description="filter by 'betaTesters' relationship dimension")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum number of groups to return per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppsBetaTesterUsagesV1MetricResponse:
        """apps_beta_tester_usages_get_metrics


        :param id: the id of the requested resource (required)
        :type id: str
        :param period: the duration of the reporting period
        :type period: str
        :param group_by: the dimension by which to group the results
        :type group_by: List[str]
        :param filter_beta_testers: filter by 'betaTesters' relationship dimension
        :type filter_beta_testers: str
        :param limit: maximum number of groups to return per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_tester_usages_get_metrics_serialize(
            id=id,
            period=period,
            group_by=group_by,
            filter_beta_testers=filter_beta_testers,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppsBetaTesterUsagesV1MetricResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_tester_usages_get_metrics_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        period: Annotated[Optional[StrictStr], Field(description="the duration of the reporting period")] = None,
        group_by: Annotated[Optional[List[StrictStr]], Field(description="the dimension by which to group the results")] = None,
        filter_beta_testers: Annotated[Optional[StrictStr], Field(description="filter by 'betaTesters' relationship dimension")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum number of groups to return per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppsBetaTesterUsagesV1MetricResponse]:
        """apps_beta_tester_usages_get_metrics


        :param id: the id of the requested resource (required)
        :type id: str
        :param period: the duration of the reporting period
        :type period: str
        :param group_by: the dimension by which to group the results
        :type group_by: List[str]
        :param filter_beta_testers: filter by 'betaTesters' relationship dimension
        :type filter_beta_testers: str
        :param limit: maximum number of groups to return per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_tester_usages_get_metrics_serialize(
            id=id,
            period=period,
            group_by=group_by,
            filter_beta_testers=filter_beta_testers,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppsBetaTesterUsagesV1MetricResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_tester_usages_get_metrics_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        period: Annotated[Optional[StrictStr], Field(description="the duration of the reporting period")] = None,
        group_by: Annotated[Optional[List[StrictStr]], Field(description="the dimension by which to group the results")] = None,
        filter_beta_testers: Annotated[Optional[StrictStr], Field(description="filter by 'betaTesters' relationship dimension")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum number of groups to return per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_tester_usages_get_metrics


        :param id: the id of the requested resource (required)
        :type id: str
        :param period: the duration of the reporting period
        :type period: str
        :param group_by: the dimension by which to group the results
        :type group_by: List[str]
        :param filter_beta_testers: filter by 'betaTesters' relationship dimension
        :type filter_beta_testers: str
        :param limit: maximum number of groups to return per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_tester_usages_get_metrics_serialize(
            id=id,
            period=period,
            group_by=group_by,
            filter_beta_testers=filter_beta_testers,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppsBetaTesterUsagesV1MetricResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_tester_usages_get_metrics_serialize(
        self,
        id,
        period,
        group_by,
        filter_beta_testers,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'groupBy': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if period is not None:
            
            _query_params.append(('period', period))
            
        if group_by is not None:
            
            _query_params.append(('groupBy', group_by))
            
        if filter_beta_testers is not None:
            
            _query_params.append(('filter[betaTesters]', filter_beta_testers))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/metrics/betaTesterUsages',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_beta_testers_delete_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        app_beta_testers_linkages_request: Annotated[AppBetaTestersLinkagesRequest, Field(description="List of related linkages")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """apps_beta_testers_delete_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param app_beta_testers_linkages_request: List of related linkages (required)
        :type app_beta_testers_linkages_request: AppBetaTestersLinkagesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_testers_delete_to_many_relationship_serialize(
            id=id,
            app_beta_testers_linkages_request=app_beta_testers_linkages_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '422': "ErrorResponse",
            '409': "ErrorResponse",
            '202': None,
            '204': None,
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_beta_testers_delete_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        app_beta_testers_linkages_request: Annotated[AppBetaTestersLinkagesRequest, Field(description="List of related linkages")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """apps_beta_testers_delete_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param app_beta_testers_linkages_request: List of related linkages (required)
        :type app_beta_testers_linkages_request: AppBetaTestersLinkagesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_testers_delete_to_many_relationship_serialize(
            id=id,
            app_beta_testers_linkages_request=app_beta_testers_linkages_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '422': "ErrorResponse",
            '409': "ErrorResponse",
            '202': None,
            '204': None,
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_beta_testers_delete_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        app_beta_testers_linkages_request: Annotated[AppBetaTestersLinkagesRequest, Field(description="List of related linkages")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_beta_testers_delete_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param app_beta_testers_linkages_request: List of related linkages (required)
        :type app_beta_testers_linkages_request: AppBetaTestersLinkagesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_beta_testers_delete_to_many_relationship_serialize(
            id=id,
            app_beta_testers_linkages_request=app_beta_testers_linkages_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '422': "ErrorResponse",
            '409': "ErrorResponse",
            '202': None,
            '204': None,
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_beta_testers_delete_to_many_relationship_serialize(
        self,
        id,
        app_beta_testers_linkages_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if app_beta_testers_linkages_request is not None:
            _body_params = app_beta_testers_linkages_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/apps/{id}/relationships/betaTesters',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_builds_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BuildsWithoutIncludesResponse:
        """apps_builds_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_builds_get_to_many_related_serialize(
            id=id,
            fields_builds=fields_builds,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BuildsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_builds_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BuildsWithoutIncludesResponse]:
        """apps_builds_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_builds_get_to_many_related_serialize(
            id=id,
            fields_builds=fields_builds,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BuildsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_builds_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_builds_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_builds_get_to_many_related_serialize(
            id=id,
            fields_builds=fields_builds,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "BuildsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_builds_get_to_many_related_serialize(
        self,
        id,
        fields_builds,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[builds]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_builds is not None:
            
            _query_params.append(('fields[builds]', fields_builds))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/builds',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_builds_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppBuildsLinkagesResponse:
        """apps_builds_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_builds_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBuildsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_builds_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppBuildsLinkagesResponse]:
        """apps_builds_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_builds_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBuildsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_builds_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_builds_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_builds_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppBuildsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_builds_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/builds',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_ci_product_get_to_one_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_ci_products: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ciProducts")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_bundle_ids: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type bundleIds")] = None,
        fields_scm_repositories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type scmRepositories")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_primary_repositories: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related primaryRepositories returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CiProductResponse:
        """apps_ci_product_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_ci_products: the fields to include for returned resources of type ciProducts
        :type fields_ci_products: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_bundle_ids: the fields to include for returned resources of type bundleIds
        :type fields_bundle_ids: List[str]
        :param fields_scm_repositories: the fields to include for returned resources of type scmRepositories
        :type fields_scm_repositories: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_primary_repositories: maximum number of related primaryRepositories returned (when they are included)
        :type limit_primary_repositories: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_ci_product_get_to_one_related_serialize(
            id=id,
            fields_ci_products=fields_ci_products,
            fields_apps=fields_apps,
            fields_bundle_ids=fields_bundle_ids,
            fields_scm_repositories=fields_scm_repositories,
            include=include,
            limit_primary_repositories=limit_primary_repositories,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "CiProductResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_ci_product_get_to_one_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_ci_products: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ciProducts")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_bundle_ids: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type bundleIds")] = None,
        fields_scm_repositories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type scmRepositories")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_primary_repositories: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related primaryRepositories returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CiProductResponse]:
        """apps_ci_product_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_ci_products: the fields to include for returned resources of type ciProducts
        :type fields_ci_products: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_bundle_ids: the fields to include for returned resources of type bundleIds
        :type fields_bundle_ids: List[str]
        :param fields_scm_repositories: the fields to include for returned resources of type scmRepositories
        :type fields_scm_repositories: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_primary_repositories: maximum number of related primaryRepositories returned (when they are included)
        :type limit_primary_repositories: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_ci_product_get_to_one_related_serialize(
            id=id,
            fields_ci_products=fields_ci_products,
            fields_apps=fields_apps,
            fields_bundle_ids=fields_bundle_ids,
            fields_scm_repositories=fields_scm_repositories,
            include=include,
            limit_primary_repositories=limit_primary_repositories,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "CiProductResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_ci_product_get_to_one_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_ci_products: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ciProducts")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_bundle_ids: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type bundleIds")] = None,
        fields_scm_repositories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type scmRepositories")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_primary_repositories: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related primaryRepositories returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_ci_product_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_ci_products: the fields to include for returned resources of type ciProducts
        :type fields_ci_products: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_bundle_ids: the fields to include for returned resources of type bundleIds
        :type fields_bundle_ids: List[str]
        :param fields_scm_repositories: the fields to include for returned resources of type scmRepositories
        :type fields_scm_repositories: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_primary_repositories: maximum number of related primaryRepositories returned (when they are included)
        :type limit_primary_repositories: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_ci_product_get_to_one_related_serialize(
            id=id,
            fields_ci_products=fields_ci_products,
            fields_apps=fields_apps,
            fields_bundle_ids=fields_bundle_ids,
            fields_scm_repositories=fields_scm_repositories,
            include=include,
            limit_primary_repositories=limit_primary_repositories,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "CiProductResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_ci_product_get_to_one_related_serialize(
        self,
        id,
        fields_ci_products,
        fields_apps,
        fields_bundle_ids,
        fields_scm_repositories,
        include,
        limit_primary_repositories,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[ciProducts]': 'csv',
            'fields[apps]': 'csv',
            'fields[bundleIds]': 'csv',
            'fields[scmRepositories]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_ci_products is not None:
            
            _query_params.append(('fields[ciProducts]', fields_ci_products))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_bundle_ids is not None:
            
            _query_params.append(('fields[bundleIds]', fields_bundle_ids))
            
        if fields_scm_repositories is not None:
            
            _query_params.append(('fields[scmRepositories]', fields_scm_repositories))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_primary_repositories is not None:
            
            _query_params.append(('limit[primaryRepositories]', limit_primary_repositories))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/ciProduct',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_ci_product_get_to_one_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppCiProductLinkageResponse:
        """apps_ci_product_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_ci_product_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppCiProductLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_ci_product_get_to_one_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppCiProductLinkageResponse]:
        """apps_ci_product_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_ci_product_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppCiProductLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_ci_product_get_to_one_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_ci_product_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_ci_product_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppCiProductLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_ci_product_get_to_one_relationship_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/ciProduct',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_customer_review_summarizations_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[List[StrictStr], Field(description="filter by attribute 'platform'")],
        filter_territory: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'territory'")] = None,
        fields_customer_review_summarizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type customerReviewSummarizations")] = None,
        fields_territories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territories")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerReviewSummarizationsResponse:
        """apps_customer_review_summarizations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform' (required)
        :type filter_platform: List[str]
        :param filter_territory: filter by id(s) of related 'territory'
        :type filter_territory: List[str]
        :param fields_customer_review_summarizations: the fields to include for returned resources of type customerReviewSummarizations
        :type fields_customer_review_summarizations: List[str]
        :param fields_territories: the fields to include for returned resources of type territories
        :type fields_territories: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_customer_review_summarizations_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_territory=filter_territory,
            fields_customer_review_summarizations=fields_customer_review_summarizations,
            fields_territories=fields_territories,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "CustomerReviewSummarizationsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_customer_review_summarizations_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[List[StrictStr], Field(description="filter by attribute 'platform'")],
        filter_territory: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'territory'")] = None,
        fields_customer_review_summarizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type customerReviewSummarizations")] = None,
        fields_territories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territories")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerReviewSummarizationsResponse]:
        """apps_customer_review_summarizations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform' (required)
        :type filter_platform: List[str]
        :param filter_territory: filter by id(s) of related 'territory'
        :type filter_territory: List[str]
        :param fields_customer_review_summarizations: the fields to include for returned resources of type customerReviewSummarizations
        :type fields_customer_review_summarizations: List[str]
        :param fields_territories: the fields to include for returned resources of type territories
        :type fields_territories: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_customer_review_summarizations_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_territory=filter_territory,
            fields_customer_review_summarizations=fields_customer_review_summarizations,
            fields_territories=fields_territories,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "CustomerReviewSummarizationsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_customer_review_summarizations_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[List[StrictStr], Field(description="filter by attribute 'platform'")],
        filter_territory: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'territory'")] = None,
        fields_customer_review_summarizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type customerReviewSummarizations")] = None,
        fields_territories: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type territories")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_customer_review_summarizations_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform' (required)
        :type filter_platform: List[str]
        :param filter_territory: filter by id(s) of related 'territory'
        :type filter_territory: List[str]
        :param fields_customer_review_summarizations: the fields to include for returned resources of type customerReviewSummarizations
        :type fields_customer_review_summarizations: List[str]
        :param fields_territories: the fields to include for returned resources of type territories
        :type fields_territories: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_customer_review_summarizations_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_territory=filter_territory,
            fields_customer_review_summarizations=fields_customer_review_summarizations,
            fields_territories=fields_territories,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "CustomerReviewSummarizationsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_customer_review_summarizations_get_to_many_related_serialize(
        self,
        id,
        filter_platform,
        filter_territory,
        fields_customer_review_summarizations,
        fields_territories,
        limit,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[platform]': 'csv',
            'filter[territory]': 'csv',
            'fields[customerReviewSummarizations]': 'csv',
            'fields[territories]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_platform is not None:
            
            _query_params.append(('filter[platform]', filter_platform))
            
        if filter_territory is not None:
            
            _query_params.append(('filter[territory]', filter_territory))
            
        if fields_customer_review_summarizations is not None:
            
            _query_params.append(('fields[customerReviewSummarizations]', fields_customer_review_summarizations))
            
        if fields_territories is not None:
            
            _query_params.append(('fields[territories]', fields_territories))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/customerReviewSummarizations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_customer_reviews_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_territory: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'territory'")] = None,
        filter_rating: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'rating'")] = None,
        exists_published_response: Annotated[Optional[StrictBool], Field(description="filter by publishedResponse")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_customer_reviews: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type customerReviews")] = None,
        fields_customer_review_responses: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type customerReviewResponses")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerReviewsResponse:
        """apps_customer_reviews_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_territory: filter by attribute 'territory'
        :type filter_territory: List[str]
        :param filter_rating: filter by attribute 'rating'
        :type filter_rating: List[str]
        :param exists_published_response: filter by publishedResponse
        :type exists_published_response: bool
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_customer_reviews: the fields to include for returned resources of type customerReviews
        :type fields_customer_reviews: List[str]
        :param fields_customer_review_responses: the fields to include for returned resources of type customerReviewResponses
        :type fields_customer_review_responses: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_customer_reviews_get_to_many_related_serialize(
            id=id,
            filter_territory=filter_territory,
            filter_rating=filter_rating,
            exists_published_response=exists_published_response,
            sort=sort,
            fields_customer_reviews=fields_customer_reviews,
            fields_customer_review_responses=fields_customer_review_responses,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "CustomerReviewsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_customer_reviews_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_territory: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'territory'")] = None,
        filter_rating: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'rating'")] = None,
        exists_published_response: Annotated[Optional[StrictBool], Field(description="filter by publishedResponse")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_customer_reviews: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type customerReviews")] = None,
        fields_customer_review_responses: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type customerReviewResponses")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerReviewsResponse]:
        """apps_customer_reviews_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_territory: filter by attribute 'territory'
        :type filter_territory: List[str]
        :param filter_rating: filter by attribute 'rating'
        :type filter_rating: List[str]
        :param exists_published_response: filter by publishedResponse
        :type exists_published_response: bool
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_customer_reviews: the fields to include for returned resources of type customerReviews
        :type fields_customer_reviews: List[str]
        :param fields_customer_review_responses: the fields to include for returned resources of type customerReviewResponses
        :type fields_customer_review_responses: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_customer_reviews_get_to_many_related_serialize(
            id=id,
            filter_territory=filter_territory,
            filter_rating=filter_rating,
            exists_published_response=exists_published_response,
            sort=sort,
            fields_customer_reviews=fields_customer_reviews,
            fields_customer_review_responses=fields_customer_review_responses,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "CustomerReviewsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_customer_reviews_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_territory: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'territory'")] = None,
        filter_rating: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'rating'")] = None,
        exists_published_response: Annotated[Optional[StrictBool], Field(description="filter by publishedResponse")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_customer_reviews: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type customerReviews")] = None,
        fields_customer_review_responses: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type customerReviewResponses")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_customer_reviews_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_territory: filter by attribute 'territory'
        :type filter_territory: List[str]
        :param filter_rating: filter by attribute 'rating'
        :type filter_rating: List[str]
        :param exists_published_response: filter by publishedResponse
        :type exists_published_response: bool
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_customer_reviews: the fields to include for returned resources of type customerReviews
        :type fields_customer_reviews: List[str]
        :param fields_customer_review_responses: the fields to include for returned resources of type customerReviewResponses
        :type fields_customer_review_responses: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_customer_reviews_get_to_many_related_serialize(
            id=id,
            filter_territory=filter_territory,
            filter_rating=filter_rating,
            exists_published_response=exists_published_response,
            sort=sort,
            fields_customer_reviews=fields_customer_reviews,
            fields_customer_review_responses=fields_customer_review_responses,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "CustomerReviewsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_customer_reviews_get_to_many_related_serialize(
        self,
        id,
        filter_territory,
        filter_rating,
        exists_published_response,
        sort,
        fields_customer_reviews,
        fields_customer_review_responses,
        limit,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[territory]': 'csv',
            'filter[rating]': 'csv',
            'sort': 'csv',
            'fields[customerReviews]': 'csv',
            'fields[customerReviewResponses]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_territory is not None:
            
            _query_params.append(('filter[territory]', filter_territory))
            
        if filter_rating is not None:
            
            _query_params.append(('filter[rating]', filter_rating))
            
        if exists_published_response is not None:
            
            _query_params.append(('exists[publishedResponse]', exists_published_response))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if fields_customer_reviews is not None:
            
            _query_params.append(('fields[customerReviews]', fields_customer_reviews))
            
        if fields_customer_review_responses is not None:
            
            _query_params.append(('fields[customerReviewResponses]', fields_customer_review_responses))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/customerReviews',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_customer_reviews_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppCustomerReviewsLinkagesResponse:
        """apps_customer_reviews_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_customer_reviews_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppCustomerReviewsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_customer_reviews_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppCustomerReviewsLinkagesResponse]:
        """apps_customer_reviews_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_customer_reviews_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppCustomerReviewsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_customer_reviews_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_customer_reviews_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_customer_reviews_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppCustomerReviewsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_customer_reviews_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/customerReviews',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_end_user_license_agreement_get_to_one_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_end_user_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type endUserLicenseAgreements")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndUserLicenseAgreementWithoutIncludesResponse:
        """apps_end_user_license_agreement_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_end_user_license_agreements: the fields to include for returned resources of type endUserLicenseAgreements
        :type fields_end_user_license_agreements: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_end_user_license_agreement_get_to_one_related_serialize(
            id=id,
            fields_end_user_license_agreements=fields_end_user_license_agreements,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "EndUserLicenseAgreementWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_end_user_license_agreement_get_to_one_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_end_user_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type endUserLicenseAgreements")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndUserLicenseAgreementWithoutIncludesResponse]:
        """apps_end_user_license_agreement_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_end_user_license_agreements: the fields to include for returned resources of type endUserLicenseAgreements
        :type fields_end_user_license_agreements: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_end_user_license_agreement_get_to_one_related_serialize(
            id=id,
            fields_end_user_license_agreements=fields_end_user_license_agreements,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "EndUserLicenseAgreementWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_end_user_license_agreement_get_to_one_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_end_user_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type endUserLicenseAgreements")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_end_user_license_agreement_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_end_user_license_agreements: the fields to include for returned resources of type endUserLicenseAgreements
        :type fields_end_user_license_agreements: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_end_user_license_agreement_get_to_one_related_serialize(
            id=id,
            fields_end_user_license_agreements=fields_end_user_license_agreements,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "EndUserLicenseAgreementWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_end_user_license_agreement_get_to_one_related_serialize(
        self,
        id,
        fields_end_user_license_agreements,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[endUserLicenseAgreements]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_end_user_license_agreements is not None:
            
            _query_params.append(('fields[endUserLicenseAgreements]', fields_end_user_license_agreements))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/endUserLicenseAgreement',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_end_user_license_agreement_get_to_one_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppEndUserLicenseAgreementLinkageResponse:
        """apps_end_user_license_agreement_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_end_user_license_agreement_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppEndUserLicenseAgreementLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_end_user_license_agreement_get_to_one_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppEndUserLicenseAgreementLinkageResponse]:
        """apps_end_user_license_agreement_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_end_user_license_agreement_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppEndUserLicenseAgreementLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_end_user_license_agreement_get_to_one_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_end_user_license_agreement_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_end_user_license_agreement_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppEndUserLicenseAgreementLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_end_user_license_agreement_get_to_one_relationship_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/endUserLicenseAgreement',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_game_center_detail_get_to_one_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_game_center_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterDetails")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_game_center_app_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAppVersions")] = None,
        fields_game_center_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterGroups")] = None,
        fields_game_center_leaderboards: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboards")] = None,
        fields_game_center_leaderboard_sets: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboardSets")] = None,
        fields_game_center_achievements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAchievements")] = None,
        fields_game_center_activities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterActivities")] = None,
        fields_game_center_challenges: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterChallenges")] = None,
        fields_game_center_achievement_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAchievementReleases")] = None,
        fields_game_center_activity_version_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterActivityVersionReleases")] = None,
        fields_game_center_challenge_version_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterChallengeVersionReleases")] = None,
        fields_game_center_leaderboard_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboardReleases")] = None,
        fields_game_center_leaderboard_set_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboardSetReleases")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_game_center_app_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterAppVersions returned (when they are included)")] = None,
        limit_game_center_leaderboards: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterLeaderboards returned (when they are included)")] = None,
        limit_game_center_leaderboard_sets: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterLeaderboardSets returned (when they are included)")] = None,
        limit_game_center_achievements: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterAchievements returned (when they are included)")] = None,
        limit_game_center_activities: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterActivities returned (when they are included)")] = None,
        limit_game_center_challenges: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterChallenges returned (when they are included)")] = None,
        limit_achievement_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related achievementReleases returned (when they are included)")] = None,
        limit_activity_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related activityReleases returned (when they are included)")] = None,
        limit_challenge_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related challengeReleases returned (when they are included)")] = None,
        limit_leaderboard_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related leaderboardReleases returned (when they are included)")] = None,
        limit_leaderboard_set_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related leaderboardSetReleases returned (when they are included)")] = None,
        limit_challenges_minimum_platform_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related challengesMinimumPlatformVersions returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GameCenterDetailResponse:
        """apps_game_center_detail_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_game_center_details: the fields to include for returned resources of type gameCenterDetails
        :type fields_game_center_details: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_game_center_app_versions: the fields to include for returned resources of type gameCenterAppVersions
        :type fields_game_center_app_versions: List[str]
        :param fields_game_center_groups: the fields to include for returned resources of type gameCenterGroups
        :type fields_game_center_groups: List[str]
        :param fields_game_center_leaderboards: the fields to include for returned resources of type gameCenterLeaderboards
        :type fields_game_center_leaderboards: List[str]
        :param fields_game_center_leaderboard_sets: the fields to include for returned resources of type gameCenterLeaderboardSets
        :type fields_game_center_leaderboard_sets: List[str]
        :param fields_game_center_achievements: the fields to include for returned resources of type gameCenterAchievements
        :type fields_game_center_achievements: List[str]
        :param fields_game_center_activities: the fields to include for returned resources of type gameCenterActivities
        :type fields_game_center_activities: List[str]
        :param fields_game_center_challenges: the fields to include for returned resources of type gameCenterChallenges
        :type fields_game_center_challenges: List[str]
        :param fields_game_center_achievement_releases: the fields to include for returned resources of type gameCenterAchievementReleases
        :type fields_game_center_achievement_releases: List[str]
        :param fields_game_center_activity_version_releases: the fields to include for returned resources of type gameCenterActivityVersionReleases
        :type fields_game_center_activity_version_releases: List[str]
        :param fields_game_center_challenge_version_releases: the fields to include for returned resources of type gameCenterChallengeVersionReleases
        :type fields_game_center_challenge_version_releases: List[str]
        :param fields_game_center_leaderboard_releases: the fields to include for returned resources of type gameCenterLeaderboardReleases
        :type fields_game_center_leaderboard_releases: List[str]
        :param fields_game_center_leaderboard_set_releases: the fields to include for returned resources of type gameCenterLeaderboardSetReleases
        :type fields_game_center_leaderboard_set_releases: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_game_center_app_versions: maximum number of related gameCenterAppVersions returned (when they are included)
        :type limit_game_center_app_versions: int
        :param limit_game_center_leaderboards: maximum number of related gameCenterLeaderboards returned (when they are included)
        :type limit_game_center_leaderboards: int
        :param limit_game_center_leaderboard_sets: maximum number of related gameCenterLeaderboardSets returned (when they are included)
        :type limit_game_center_leaderboard_sets: int
        :param limit_game_center_achievements: maximum number of related gameCenterAchievements returned (when they are included)
        :type limit_game_center_achievements: int
        :param limit_game_center_activities: maximum number of related gameCenterActivities returned (when they are included)
        :type limit_game_center_activities: int
        :param limit_game_center_challenges: maximum number of related gameCenterChallenges returned (when they are included)
        :type limit_game_center_challenges: int
        :param limit_achievement_releases: maximum number of related achievementReleases returned (when they are included)
        :type limit_achievement_releases: int
        :param limit_activity_releases: maximum number of related activityReleases returned (when they are included)
        :type limit_activity_releases: int
        :param limit_challenge_releases: maximum number of related challengeReleases returned (when they are included)
        :type limit_challenge_releases: int
        :param limit_leaderboard_releases: maximum number of related leaderboardReleases returned (when they are included)
        :type limit_leaderboard_releases: int
        :param limit_leaderboard_set_releases: maximum number of related leaderboardSetReleases returned (when they are included)
        :type limit_leaderboard_set_releases: int
        :param limit_challenges_minimum_platform_versions: maximum number of related challengesMinimumPlatformVersions returned (when they are included)
        :type limit_challenges_minimum_platform_versions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_game_center_detail_get_to_one_related_serialize(
            id=id,
            fields_game_center_details=fields_game_center_details,
            fields_apps=fields_apps,
            fields_game_center_app_versions=fields_game_center_app_versions,
            fields_game_center_groups=fields_game_center_groups,
            fields_game_center_leaderboards=fields_game_center_leaderboards,
            fields_game_center_leaderboard_sets=fields_game_center_leaderboard_sets,
            fields_game_center_achievements=fields_game_center_achievements,
            fields_game_center_activities=fields_game_center_activities,
            fields_game_center_challenges=fields_game_center_challenges,
            fields_game_center_achievement_releases=fields_game_center_achievement_releases,
            fields_game_center_activity_version_releases=fields_game_center_activity_version_releases,
            fields_game_center_challenge_version_releases=fields_game_center_challenge_version_releases,
            fields_game_center_leaderboard_releases=fields_game_center_leaderboard_releases,
            fields_game_center_leaderboard_set_releases=fields_game_center_leaderboard_set_releases,
            fields_app_store_versions=fields_app_store_versions,
            include=include,
            limit_game_center_app_versions=limit_game_center_app_versions,
            limit_game_center_leaderboards=limit_game_center_leaderboards,
            limit_game_center_leaderboard_sets=limit_game_center_leaderboard_sets,
            limit_game_center_achievements=limit_game_center_achievements,
            limit_game_center_activities=limit_game_center_activities,
            limit_game_center_challenges=limit_game_center_challenges,
            limit_achievement_releases=limit_achievement_releases,
            limit_activity_releases=limit_activity_releases,
            limit_challenge_releases=limit_challenge_releases,
            limit_leaderboard_releases=limit_leaderboard_releases,
            limit_leaderboard_set_releases=limit_leaderboard_set_releases,
            limit_challenges_minimum_platform_versions=limit_challenges_minimum_platform_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "GameCenterDetailResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_game_center_detail_get_to_one_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_game_center_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterDetails")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_game_center_app_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAppVersions")] = None,
        fields_game_center_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterGroups")] = None,
        fields_game_center_leaderboards: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboards")] = None,
        fields_game_center_leaderboard_sets: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboardSets")] = None,
        fields_game_center_achievements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAchievements")] = None,
        fields_game_center_activities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterActivities")] = None,
        fields_game_center_challenges: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterChallenges")] = None,
        fields_game_center_achievement_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAchievementReleases")] = None,
        fields_game_center_activity_version_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterActivityVersionReleases")] = None,
        fields_game_center_challenge_version_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterChallengeVersionReleases")] = None,
        fields_game_center_leaderboard_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboardReleases")] = None,
        fields_game_center_leaderboard_set_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboardSetReleases")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_game_center_app_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterAppVersions returned (when they are included)")] = None,
        limit_game_center_leaderboards: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterLeaderboards returned (when they are included)")] = None,
        limit_game_center_leaderboard_sets: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterLeaderboardSets returned (when they are included)")] = None,
        limit_game_center_achievements: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterAchievements returned (when they are included)")] = None,
        limit_game_center_activities: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterActivities returned (when they are included)")] = None,
        limit_game_center_challenges: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterChallenges returned (when they are included)")] = None,
        limit_achievement_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related achievementReleases returned (when they are included)")] = None,
        limit_activity_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related activityReleases returned (when they are included)")] = None,
        limit_challenge_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related challengeReleases returned (when they are included)")] = None,
        limit_leaderboard_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related leaderboardReleases returned (when they are included)")] = None,
        limit_leaderboard_set_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related leaderboardSetReleases returned (when they are included)")] = None,
        limit_challenges_minimum_platform_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related challengesMinimumPlatformVersions returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GameCenterDetailResponse]:
        """apps_game_center_detail_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_game_center_details: the fields to include for returned resources of type gameCenterDetails
        :type fields_game_center_details: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_game_center_app_versions: the fields to include for returned resources of type gameCenterAppVersions
        :type fields_game_center_app_versions: List[str]
        :param fields_game_center_groups: the fields to include for returned resources of type gameCenterGroups
        :type fields_game_center_groups: List[str]
        :param fields_game_center_leaderboards: the fields to include for returned resources of type gameCenterLeaderboards
        :type fields_game_center_leaderboards: List[str]
        :param fields_game_center_leaderboard_sets: the fields to include for returned resources of type gameCenterLeaderboardSets
        :type fields_game_center_leaderboard_sets: List[str]
        :param fields_game_center_achievements: the fields to include for returned resources of type gameCenterAchievements
        :type fields_game_center_achievements: List[str]
        :param fields_game_center_activities: the fields to include for returned resources of type gameCenterActivities
        :type fields_game_center_activities: List[str]
        :param fields_game_center_challenges: the fields to include for returned resources of type gameCenterChallenges
        :type fields_game_center_challenges: List[str]
        :param fields_game_center_achievement_releases: the fields to include for returned resources of type gameCenterAchievementReleases
        :type fields_game_center_achievement_releases: List[str]
        :param fields_game_center_activity_version_releases: the fields to include for returned resources of type gameCenterActivityVersionReleases
        :type fields_game_center_activity_version_releases: List[str]
        :param fields_game_center_challenge_version_releases: the fields to include for returned resources of type gameCenterChallengeVersionReleases
        :type fields_game_center_challenge_version_releases: List[str]
        :param fields_game_center_leaderboard_releases: the fields to include for returned resources of type gameCenterLeaderboardReleases
        :type fields_game_center_leaderboard_releases: List[str]
        :param fields_game_center_leaderboard_set_releases: the fields to include for returned resources of type gameCenterLeaderboardSetReleases
        :type fields_game_center_leaderboard_set_releases: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_game_center_app_versions: maximum number of related gameCenterAppVersions returned (when they are included)
        :type limit_game_center_app_versions: int
        :param limit_game_center_leaderboards: maximum number of related gameCenterLeaderboards returned (when they are included)
        :type limit_game_center_leaderboards: int
        :param limit_game_center_leaderboard_sets: maximum number of related gameCenterLeaderboardSets returned (when they are included)
        :type limit_game_center_leaderboard_sets: int
        :param limit_game_center_achievements: maximum number of related gameCenterAchievements returned (when they are included)
        :type limit_game_center_achievements: int
        :param limit_game_center_activities: maximum number of related gameCenterActivities returned (when they are included)
        :type limit_game_center_activities: int
        :param limit_game_center_challenges: maximum number of related gameCenterChallenges returned (when they are included)
        :type limit_game_center_challenges: int
        :param limit_achievement_releases: maximum number of related achievementReleases returned (when they are included)
        :type limit_achievement_releases: int
        :param limit_activity_releases: maximum number of related activityReleases returned (when they are included)
        :type limit_activity_releases: int
        :param limit_challenge_releases: maximum number of related challengeReleases returned (when they are included)
        :type limit_challenge_releases: int
        :param limit_leaderboard_releases: maximum number of related leaderboardReleases returned (when they are included)
        :type limit_leaderboard_releases: int
        :param limit_leaderboard_set_releases: maximum number of related leaderboardSetReleases returned (when they are included)
        :type limit_leaderboard_set_releases: int
        :param limit_challenges_minimum_platform_versions: maximum number of related challengesMinimumPlatformVersions returned (when they are included)
        :type limit_challenges_minimum_platform_versions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_game_center_detail_get_to_one_related_serialize(
            id=id,
            fields_game_center_details=fields_game_center_details,
            fields_apps=fields_apps,
            fields_game_center_app_versions=fields_game_center_app_versions,
            fields_game_center_groups=fields_game_center_groups,
            fields_game_center_leaderboards=fields_game_center_leaderboards,
            fields_game_center_leaderboard_sets=fields_game_center_leaderboard_sets,
            fields_game_center_achievements=fields_game_center_achievements,
            fields_game_center_activities=fields_game_center_activities,
            fields_game_center_challenges=fields_game_center_challenges,
            fields_game_center_achievement_releases=fields_game_center_achievement_releases,
            fields_game_center_activity_version_releases=fields_game_center_activity_version_releases,
            fields_game_center_challenge_version_releases=fields_game_center_challenge_version_releases,
            fields_game_center_leaderboard_releases=fields_game_center_leaderboard_releases,
            fields_game_center_leaderboard_set_releases=fields_game_center_leaderboard_set_releases,
            fields_app_store_versions=fields_app_store_versions,
            include=include,
            limit_game_center_app_versions=limit_game_center_app_versions,
            limit_game_center_leaderboards=limit_game_center_leaderboards,
            limit_game_center_leaderboard_sets=limit_game_center_leaderboard_sets,
            limit_game_center_achievements=limit_game_center_achievements,
            limit_game_center_activities=limit_game_center_activities,
            limit_game_center_challenges=limit_game_center_challenges,
            limit_achievement_releases=limit_achievement_releases,
            limit_activity_releases=limit_activity_releases,
            limit_challenge_releases=limit_challenge_releases,
            limit_leaderboard_releases=limit_leaderboard_releases,
            limit_leaderboard_set_releases=limit_leaderboard_set_releases,
            limit_challenges_minimum_platform_versions=limit_challenges_minimum_platform_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "GameCenterDetailResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_game_center_detail_get_to_one_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_game_center_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterDetails")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_game_center_app_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAppVersions")] = None,
        fields_game_center_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterGroups")] = None,
        fields_game_center_leaderboards: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboards")] = None,
        fields_game_center_leaderboard_sets: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboardSets")] = None,
        fields_game_center_achievements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAchievements")] = None,
        fields_game_center_activities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterActivities")] = None,
        fields_game_center_challenges: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterChallenges")] = None,
        fields_game_center_achievement_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterAchievementReleases")] = None,
        fields_game_center_activity_version_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterActivityVersionReleases")] = None,
        fields_game_center_challenge_version_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterChallengeVersionReleases")] = None,
        fields_game_center_leaderboard_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboardReleases")] = None,
        fields_game_center_leaderboard_set_releases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterLeaderboardSetReleases")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_game_center_app_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterAppVersions returned (when they are included)")] = None,
        limit_game_center_leaderboards: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterLeaderboards returned (when they are included)")] = None,
        limit_game_center_leaderboard_sets: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterLeaderboardSets returned (when they are included)")] = None,
        limit_game_center_achievements: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterAchievements returned (when they are included)")] = None,
        limit_game_center_activities: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterActivities returned (when they are included)")] = None,
        limit_game_center_challenges: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterChallenges returned (when they are included)")] = None,
        limit_achievement_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related achievementReleases returned (when they are included)")] = None,
        limit_activity_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related activityReleases returned (when they are included)")] = None,
        limit_challenge_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related challengeReleases returned (when they are included)")] = None,
        limit_leaderboard_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related leaderboardReleases returned (when they are included)")] = None,
        limit_leaderboard_set_releases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related leaderboardSetReleases returned (when they are included)")] = None,
        limit_challenges_minimum_platform_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related challengesMinimumPlatformVersions returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_game_center_detail_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_game_center_details: the fields to include for returned resources of type gameCenterDetails
        :type fields_game_center_details: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_game_center_app_versions: the fields to include for returned resources of type gameCenterAppVersions
        :type fields_game_center_app_versions: List[str]
        :param fields_game_center_groups: the fields to include for returned resources of type gameCenterGroups
        :type fields_game_center_groups: List[str]
        :param fields_game_center_leaderboards: the fields to include for returned resources of type gameCenterLeaderboards
        :type fields_game_center_leaderboards: List[str]
        :param fields_game_center_leaderboard_sets: the fields to include for returned resources of type gameCenterLeaderboardSets
        :type fields_game_center_leaderboard_sets: List[str]
        :param fields_game_center_achievements: the fields to include for returned resources of type gameCenterAchievements
        :type fields_game_center_achievements: List[str]
        :param fields_game_center_activities: the fields to include for returned resources of type gameCenterActivities
        :type fields_game_center_activities: List[str]
        :param fields_game_center_challenges: the fields to include for returned resources of type gameCenterChallenges
        :type fields_game_center_challenges: List[str]
        :param fields_game_center_achievement_releases: the fields to include for returned resources of type gameCenterAchievementReleases
        :type fields_game_center_achievement_releases: List[str]
        :param fields_game_center_activity_version_releases: the fields to include for returned resources of type gameCenterActivityVersionReleases
        :type fields_game_center_activity_version_releases: List[str]
        :param fields_game_center_challenge_version_releases: the fields to include for returned resources of type gameCenterChallengeVersionReleases
        :type fields_game_center_challenge_version_releases: List[str]
        :param fields_game_center_leaderboard_releases: the fields to include for returned resources of type gameCenterLeaderboardReleases
        :type fields_game_center_leaderboard_releases: List[str]
        :param fields_game_center_leaderboard_set_releases: the fields to include for returned resources of type gameCenterLeaderboardSetReleases
        :type fields_game_center_leaderboard_set_releases: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_game_center_app_versions: maximum number of related gameCenterAppVersions returned (when they are included)
        :type limit_game_center_app_versions: int
        :param limit_game_center_leaderboards: maximum number of related gameCenterLeaderboards returned (when they are included)
        :type limit_game_center_leaderboards: int
        :param limit_game_center_leaderboard_sets: maximum number of related gameCenterLeaderboardSets returned (when they are included)
        :type limit_game_center_leaderboard_sets: int
        :param limit_game_center_achievements: maximum number of related gameCenterAchievements returned (when they are included)
        :type limit_game_center_achievements: int
        :param limit_game_center_activities: maximum number of related gameCenterActivities returned (when they are included)
        :type limit_game_center_activities: int
        :param limit_game_center_challenges: maximum number of related gameCenterChallenges returned (when they are included)
        :type limit_game_center_challenges: int
        :param limit_achievement_releases: maximum number of related achievementReleases returned (when they are included)
        :type limit_achievement_releases: int
        :param limit_activity_releases: maximum number of related activityReleases returned (when they are included)
        :type limit_activity_releases: int
        :param limit_challenge_releases: maximum number of related challengeReleases returned (when they are included)
        :type limit_challenge_releases: int
        :param limit_leaderboard_releases: maximum number of related leaderboardReleases returned (when they are included)
        :type limit_leaderboard_releases: int
        :param limit_leaderboard_set_releases: maximum number of related leaderboardSetReleases returned (when they are included)
        :type limit_leaderboard_set_releases: int
        :param limit_challenges_minimum_platform_versions: maximum number of related challengesMinimumPlatformVersions returned (when they are included)
        :type limit_challenges_minimum_platform_versions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_game_center_detail_get_to_one_related_serialize(
            id=id,
            fields_game_center_details=fields_game_center_details,
            fields_apps=fields_apps,
            fields_game_center_app_versions=fields_game_center_app_versions,
            fields_game_center_groups=fields_game_center_groups,
            fields_game_center_leaderboards=fields_game_center_leaderboards,
            fields_game_center_leaderboard_sets=fields_game_center_leaderboard_sets,
            fields_game_center_achievements=fields_game_center_achievements,
            fields_game_center_activities=fields_game_center_activities,
            fields_game_center_challenges=fields_game_center_challenges,
            fields_game_center_achievement_releases=fields_game_center_achievement_releases,
            fields_game_center_activity_version_releases=fields_game_center_activity_version_releases,
            fields_game_center_challenge_version_releases=fields_game_center_challenge_version_releases,
            fields_game_center_leaderboard_releases=fields_game_center_leaderboard_releases,
            fields_game_center_leaderboard_set_releases=fields_game_center_leaderboard_set_releases,
            fields_app_store_versions=fields_app_store_versions,
            include=include,
            limit_game_center_app_versions=limit_game_center_app_versions,
            limit_game_center_leaderboards=limit_game_center_leaderboards,
            limit_game_center_leaderboard_sets=limit_game_center_leaderboard_sets,
            limit_game_center_achievements=limit_game_center_achievements,
            limit_game_center_activities=limit_game_center_activities,
            limit_game_center_challenges=limit_game_center_challenges,
            limit_achievement_releases=limit_achievement_releases,
            limit_activity_releases=limit_activity_releases,
            limit_challenge_releases=limit_challenge_releases,
            limit_leaderboard_releases=limit_leaderboard_releases,
            limit_leaderboard_set_releases=limit_leaderboard_set_releases,
            limit_challenges_minimum_platform_versions=limit_challenges_minimum_platform_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "GameCenterDetailResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_game_center_detail_get_to_one_related_serialize(
        self,
        id,
        fields_game_center_details,
        fields_apps,
        fields_game_center_app_versions,
        fields_game_center_groups,
        fields_game_center_leaderboards,
        fields_game_center_leaderboard_sets,
        fields_game_center_achievements,
        fields_game_center_activities,
        fields_game_center_challenges,
        fields_game_center_achievement_releases,
        fields_game_center_activity_version_releases,
        fields_game_center_challenge_version_releases,
        fields_game_center_leaderboard_releases,
        fields_game_center_leaderboard_set_releases,
        fields_app_store_versions,
        include,
        limit_game_center_app_versions,
        limit_game_center_leaderboards,
        limit_game_center_leaderboard_sets,
        limit_game_center_achievements,
        limit_game_center_activities,
        limit_game_center_challenges,
        limit_achievement_releases,
        limit_activity_releases,
        limit_challenge_releases,
        limit_leaderboard_releases,
        limit_leaderboard_set_releases,
        limit_challenges_minimum_platform_versions,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[gameCenterDetails]': 'csv',
            'fields[apps]': 'csv',
            'fields[gameCenterAppVersions]': 'csv',
            'fields[gameCenterGroups]': 'csv',
            'fields[gameCenterLeaderboards]': 'csv',
            'fields[gameCenterLeaderboardSets]': 'csv',
            'fields[gameCenterAchievements]': 'csv',
            'fields[gameCenterActivities]': 'csv',
            'fields[gameCenterChallenges]': 'csv',
            'fields[gameCenterAchievementReleases]': 'csv',
            'fields[gameCenterActivityVersionReleases]': 'csv',
            'fields[gameCenterChallengeVersionReleases]': 'csv',
            'fields[gameCenterLeaderboardReleases]': 'csv',
            'fields[gameCenterLeaderboardSetReleases]': 'csv',
            'fields[appStoreVersions]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_game_center_details is not None:
            
            _query_params.append(('fields[gameCenterDetails]', fields_game_center_details))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_game_center_app_versions is not None:
            
            _query_params.append(('fields[gameCenterAppVersions]', fields_game_center_app_versions))
            
        if fields_game_center_groups is not None:
            
            _query_params.append(('fields[gameCenterGroups]', fields_game_center_groups))
            
        if fields_game_center_leaderboards is not None:
            
            _query_params.append(('fields[gameCenterLeaderboards]', fields_game_center_leaderboards))
            
        if fields_game_center_leaderboard_sets is not None:
            
            _query_params.append(('fields[gameCenterLeaderboardSets]', fields_game_center_leaderboard_sets))
            
        if fields_game_center_achievements is not None:
            
            _query_params.append(('fields[gameCenterAchievements]', fields_game_center_achievements))
            
        if fields_game_center_activities is not None:
            
            _query_params.append(('fields[gameCenterActivities]', fields_game_center_activities))
            
        if fields_game_center_challenges is not None:
            
            _query_params.append(('fields[gameCenterChallenges]', fields_game_center_challenges))
            
        if fields_game_center_achievement_releases is not None:
            
            _query_params.append(('fields[gameCenterAchievementReleases]', fields_game_center_achievement_releases))
            
        if fields_game_center_activity_version_releases is not None:
            
            _query_params.append(('fields[gameCenterActivityVersionReleases]', fields_game_center_activity_version_releases))
            
        if fields_game_center_challenge_version_releases is not None:
            
            _query_params.append(('fields[gameCenterChallengeVersionReleases]', fields_game_center_challenge_version_releases))
            
        if fields_game_center_leaderboard_releases is not None:
            
            _query_params.append(('fields[gameCenterLeaderboardReleases]', fields_game_center_leaderboard_releases))
            
        if fields_game_center_leaderboard_set_releases is not None:
            
            _query_params.append(('fields[gameCenterLeaderboardSetReleases]', fields_game_center_leaderboard_set_releases))
            
        if fields_app_store_versions is not None:
            
            _query_params.append(('fields[appStoreVersions]', fields_app_store_versions))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_game_center_app_versions is not None:
            
            _query_params.append(('limit[gameCenterAppVersions]', limit_game_center_app_versions))
            
        if limit_game_center_leaderboards is not None:
            
            _query_params.append(('limit[gameCenterLeaderboards]', limit_game_center_leaderboards))
            
        if limit_game_center_leaderboard_sets is not None:
            
            _query_params.append(('limit[gameCenterLeaderboardSets]', limit_game_center_leaderboard_sets))
            
        if limit_game_center_achievements is not None:
            
            _query_params.append(('limit[gameCenterAchievements]', limit_game_center_achievements))
            
        if limit_game_center_activities is not None:
            
            _query_params.append(('limit[gameCenterActivities]', limit_game_center_activities))
            
        if limit_game_center_challenges is not None:
            
            _query_params.append(('limit[gameCenterChallenges]', limit_game_center_challenges))
            
        if limit_achievement_releases is not None:
            
            _query_params.append(('limit[achievementReleases]', limit_achievement_releases))
            
        if limit_activity_releases is not None:
            
            _query_params.append(('limit[activityReleases]', limit_activity_releases))
            
        if limit_challenge_releases is not None:
            
            _query_params.append(('limit[challengeReleases]', limit_challenge_releases))
            
        if limit_leaderboard_releases is not None:
            
            _query_params.append(('limit[leaderboardReleases]', limit_leaderboard_releases))
            
        if limit_leaderboard_set_releases is not None:
            
            _query_params.append(('limit[leaderboardSetReleases]', limit_leaderboard_set_releases))
            
        if limit_challenges_minimum_platform_versions is not None:
            
            _query_params.append(('limit[challengesMinimumPlatformVersions]', limit_challenges_minimum_platform_versions))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/gameCenterDetail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_game_center_detail_get_to_one_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppGameCenterDetailLinkageResponse:
        """apps_game_center_detail_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_game_center_detail_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppGameCenterDetailLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_game_center_detail_get_to_one_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppGameCenterDetailLinkageResponse]:
        """apps_game_center_detail_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_game_center_detail_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppGameCenterDetailLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_game_center_detail_get_to_one_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_game_center_detail_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_game_center_detail_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppGameCenterDetailLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_game_center_detail_get_to_one_relationship_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/gameCenterDetail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_game_center_enabled_versions_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_version_string: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'versionString'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_game_center_enabled_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterEnabledVersions")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_compatible_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related compatibleVersions returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GameCenterEnabledVersionsResponse:
        """(Deprecated) apps_game_center_enabled_versions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_version_string: filter by attribute 'versionString'
        :type filter_version_string: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_game_center_enabled_versions: the fields to include for returned resources of type gameCenterEnabledVersions
        :type fields_game_center_enabled_versions: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_compatible_versions: maximum number of related compatibleVersions returned (when they are included)
        :type limit_compatible_versions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/gameCenterEnabledVersions is deprecated.", DeprecationWarning)

        _param = self._apps_game_center_enabled_versions_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_version_string=filter_version_string,
            filter_id=filter_id,
            sort=sort,
            fields_game_center_enabled_versions=fields_game_center_enabled_versions,
            fields_apps=fields_apps,
            limit=limit,
            include=include,
            limit_compatible_versions=limit_compatible_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "GameCenterEnabledVersionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_game_center_enabled_versions_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_version_string: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'versionString'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_game_center_enabled_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterEnabledVersions")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_compatible_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related compatibleVersions returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GameCenterEnabledVersionsResponse]:
        """(Deprecated) apps_game_center_enabled_versions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_version_string: filter by attribute 'versionString'
        :type filter_version_string: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_game_center_enabled_versions: the fields to include for returned resources of type gameCenterEnabledVersions
        :type fields_game_center_enabled_versions: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_compatible_versions: maximum number of related compatibleVersions returned (when they are included)
        :type limit_compatible_versions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/gameCenterEnabledVersions is deprecated.", DeprecationWarning)

        _param = self._apps_game_center_enabled_versions_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_version_string=filter_version_string,
            filter_id=filter_id,
            sort=sort,
            fields_game_center_enabled_versions=fields_game_center_enabled_versions,
            fields_apps=fields_apps,
            limit=limit,
            include=include,
            limit_compatible_versions=limit_compatible_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "GameCenterEnabledVersionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_game_center_enabled_versions_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_version_string: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'versionString'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_game_center_enabled_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterEnabledVersions")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_compatible_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related compatibleVersions returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) apps_game_center_enabled_versions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_version_string: filter by attribute 'versionString'
        :type filter_version_string: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_game_center_enabled_versions: the fields to include for returned resources of type gameCenterEnabledVersions
        :type fields_game_center_enabled_versions: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_compatible_versions: maximum number of related compatibleVersions returned (when they are included)
        :type limit_compatible_versions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/gameCenterEnabledVersions is deprecated.", DeprecationWarning)

        _param = self._apps_game_center_enabled_versions_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_version_string=filter_version_string,
            filter_id=filter_id,
            sort=sort,
            fields_game_center_enabled_versions=fields_game_center_enabled_versions,
            fields_apps=fields_apps,
            limit=limit,
            include=include,
            limit_compatible_versions=limit_compatible_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "GameCenterEnabledVersionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_game_center_enabled_versions_get_to_many_related_serialize(
        self,
        id,
        filter_platform,
        filter_version_string,
        filter_id,
        sort,
        fields_game_center_enabled_versions,
        fields_apps,
        limit,
        include,
        limit_compatible_versions,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[platform]': 'csv',
            'filter[versionString]': 'csv',
            'filter[id]': 'csv',
            'sort': 'csv',
            'fields[gameCenterEnabledVersions]': 'csv',
            'fields[apps]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_platform is not None:
            
            _query_params.append(('filter[platform]', filter_platform))
            
        if filter_version_string is not None:
            
            _query_params.append(('filter[versionString]', filter_version_string))
            
        if filter_id is not None:
            
            _query_params.append(('filter[id]', filter_id))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if fields_game_center_enabled_versions is not None:
            
            _query_params.append(('fields[gameCenterEnabledVersions]', fields_game_center_enabled_versions))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_compatible_versions is not None:
            
            _query_params.append(('limit[compatibleVersions]', limit_compatible_versions))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/gameCenterEnabledVersions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_game_center_enabled_versions_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppGameCenterEnabledVersionsLinkagesResponse:
        """(Deprecated) apps_game_center_enabled_versions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/relationships/gameCenterEnabledVersions is deprecated.", DeprecationWarning)

        _param = self._apps_game_center_enabled_versions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppGameCenterEnabledVersionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_game_center_enabled_versions_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppGameCenterEnabledVersionsLinkagesResponse]:
        """(Deprecated) apps_game_center_enabled_versions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/relationships/gameCenterEnabledVersions is deprecated.", DeprecationWarning)

        _param = self._apps_game_center_enabled_versions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppGameCenterEnabledVersionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_game_center_enabled_versions_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) apps_game_center_enabled_versions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/relationships/gameCenterEnabledVersions is deprecated.", DeprecationWarning)

        _param = self._apps_game_center_enabled_versions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppGameCenterEnabledVersionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_game_center_enabled_versions_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/gameCenterEnabledVersions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_get_collection(
        self,
        filter_name: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'name'")] = None,
        filter_bundle_id: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'bundleId'")] = None,
        filter_sku: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'sku'")] = None,
        filter_app_store_versions_app_store_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreVersions.appStoreState'")] = None,
        filter_app_store_versions_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreVersions.platform'")] = None,
        filter_app_store_versions_app_version_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreVersions.appVersionState'")] = None,
        filter_review_submissions_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'reviewSubmissions.state'")] = None,
        filter_review_submissions_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'reviewSubmissions.platform'")] = None,
        filter_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'appStoreVersions'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        exists_game_center_enabled_versions: Annotated[Optional[StrictBool], Field(description="filter by existence or non-existence of related 'gameCenterEnabledVersions'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_encryption_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarations")] = None,
        fields_ci_products: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ciProducts")] = None,
        fields_beta_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaGroups")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_pre_release_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type preReleaseVersions")] = None,
        fields_beta_app_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppLocalizations")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaLicenseAgreements")] = None,
        fields_beta_app_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppReviewDetails")] = None,
        fields_app_infos: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfos")] = None,
        fields_app_clips: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClips")] = None,
        fields_end_user_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type endUserLicenseAgreements")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_subscription_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroups")] = None,
        fields_game_center_enabled_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterEnabledVersions")] = None,
        fields_app_custom_product_pages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPages")] = None,
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_app_events: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEvents")] = None,
        fields_review_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissions")] = None,
        fields_subscription_grace_periods: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGracePeriods")] = None,
        fields_game_center_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterDetails")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_clips: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appClips returned (when they are included)")] = None,
        limit_app_custom_product_pages: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appCustomProductPages returned (when they are included)")] = None,
        limit_app_encryption_declarations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEncryptionDeclarations returned (when they are included)")] = None,
        limit_app_events: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEvents returned (when they are included)")] = None,
        limit_app_infos: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appInfos returned (when they are included)")] = None,
        limit_app_store_version_experiments_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentsV2 returned (when they are included)")] = None,
        limit_app_store_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersions returned (when they are included)")] = None,
        limit_beta_app_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaAppLocalizations returned (when they are included)")] = None,
        limit_beta_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaGroups returned (when they are included)")] = None,
        limit_builds: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related builds returned (when they are included)")] = None,
        limit_game_center_enabled_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterEnabledVersions returned (when they are included)")] = None,
        limit_in_app_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchases returned (when they are included)")] = None,
        limit_in_app_purchases_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchasesV2 returned (when they are included)")] = None,
        limit_pre_release_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related preReleaseVersions returned (when they are included)")] = None,
        limit_promoted_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related promotedPurchases returned (when they are included)")] = None,
        limit_review_submissions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related reviewSubmissions returned (when they are included)")] = None,
        limit_subscription_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptionGroups returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppsResponse:
        """apps_get_collection


        :param filter_name: filter by attribute 'name'
        :type filter_name: List[str]
        :param filter_bundle_id: filter by attribute 'bundleId'
        :type filter_bundle_id: List[str]
        :param filter_sku: filter by attribute 'sku'
        :type filter_sku: List[str]
        :param filter_app_store_versions_app_store_state: filter by attribute 'appStoreVersions.appStoreState'
        :type filter_app_store_versions_app_store_state: List[str]
        :param filter_app_store_versions_platform: filter by attribute 'appStoreVersions.platform'
        :type filter_app_store_versions_platform: List[str]
        :param filter_app_store_versions_app_version_state: filter by attribute 'appStoreVersions.appVersionState'
        :type filter_app_store_versions_app_version_state: List[str]
        :param filter_review_submissions_state: filter by attribute 'reviewSubmissions.state'
        :type filter_review_submissions_state: List[str]
        :param filter_review_submissions_platform: filter by attribute 'reviewSubmissions.platform'
        :type filter_review_submissions_platform: List[str]
        :param filter_app_store_versions: filter by id(s) of related 'appStoreVersions'
        :type filter_app_store_versions: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param exists_game_center_enabled_versions: filter by existence or non-existence of related 'gameCenterEnabledVersions'
        :type exists_game_center_enabled_versions: bool
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_encryption_declarations: the fields to include for returned resources of type appEncryptionDeclarations
        :type fields_app_encryption_declarations: List[str]
        :param fields_ci_products: the fields to include for returned resources of type ciProducts
        :type fields_ci_products: List[str]
        :param fields_beta_groups: the fields to include for returned resources of type betaGroups
        :type fields_beta_groups: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_pre_release_versions: the fields to include for returned resources of type preReleaseVersions
        :type fields_pre_release_versions: List[str]
        :param fields_beta_app_localizations: the fields to include for returned resources of type betaAppLocalizations
        :type fields_beta_app_localizations: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_license_agreements: the fields to include for returned resources of type betaLicenseAgreements
        :type fields_beta_license_agreements: List[str]
        :param fields_beta_app_review_details: the fields to include for returned resources of type betaAppReviewDetails
        :type fields_beta_app_review_details: List[str]
        :param fields_app_infos: the fields to include for returned resources of type appInfos
        :type fields_app_infos: List[str]
        :param fields_app_clips: the fields to include for returned resources of type appClips
        :type fields_app_clips: List[str]
        :param fields_end_user_license_agreements: the fields to include for returned resources of type endUserLicenseAgreements
        :type fields_end_user_license_agreements: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_subscription_groups: the fields to include for returned resources of type subscriptionGroups
        :type fields_subscription_groups: List[str]
        :param fields_game_center_enabled_versions: the fields to include for returned resources of type gameCenterEnabledVersions
        :type fields_game_center_enabled_versions: List[str]
        :param fields_app_custom_product_pages: the fields to include for returned resources of type appCustomProductPages
        :type fields_app_custom_product_pages: List[str]
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_app_events: the fields to include for returned resources of type appEvents
        :type fields_app_events: List[str]
        :param fields_review_submissions: the fields to include for returned resources of type reviewSubmissions
        :type fields_review_submissions: List[str]
        :param fields_subscription_grace_periods: the fields to include for returned resources of type subscriptionGracePeriods
        :type fields_subscription_grace_periods: List[str]
        :param fields_game_center_details: the fields to include for returned resources of type gameCenterDetails
        :type fields_game_center_details: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_clips: maximum number of related appClips returned (when they are included)
        :type limit_app_clips: int
        :param limit_app_custom_product_pages: maximum number of related appCustomProductPages returned (when they are included)
        :type limit_app_custom_product_pages: int
        :param limit_app_encryption_declarations: maximum number of related appEncryptionDeclarations returned (when they are included)
        :type limit_app_encryption_declarations: int
        :param limit_app_events: maximum number of related appEvents returned (when they are included)
        :type limit_app_events: int
        :param limit_app_infos: maximum number of related appInfos returned (when they are included)
        :type limit_app_infos: int
        :param limit_app_store_version_experiments_v2: maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
        :type limit_app_store_version_experiments_v2: int
        :param limit_app_store_versions: maximum number of related appStoreVersions returned (when they are included)
        :type limit_app_store_versions: int
        :param limit_beta_app_localizations: maximum number of related betaAppLocalizations returned (when they are included)
        :type limit_beta_app_localizations: int
        :param limit_beta_groups: maximum number of related betaGroups returned (when they are included)
        :type limit_beta_groups: int
        :param limit_builds: maximum number of related builds returned (when they are included)
        :type limit_builds: int
        :param limit_game_center_enabled_versions: maximum number of related gameCenterEnabledVersions returned (when they are included)
        :type limit_game_center_enabled_versions: int
        :param limit_in_app_purchases: maximum number of related inAppPurchases returned (when they are included)
        :type limit_in_app_purchases: int
        :param limit_in_app_purchases_v2: maximum number of related inAppPurchasesV2 returned (when they are included)
        :type limit_in_app_purchases_v2: int
        :param limit_pre_release_versions: maximum number of related preReleaseVersions returned (when they are included)
        :type limit_pre_release_versions: int
        :param limit_promoted_purchases: maximum number of related promotedPurchases returned (when they are included)
        :type limit_promoted_purchases: int
        :param limit_review_submissions: maximum number of related reviewSubmissions returned (when they are included)
        :type limit_review_submissions: int
        :param limit_subscription_groups: maximum number of related subscriptionGroups returned (when they are included)
        :type limit_subscription_groups: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_get_collection_serialize(
            filter_name=filter_name,
            filter_bundle_id=filter_bundle_id,
            filter_sku=filter_sku,
            filter_app_store_versions_app_store_state=filter_app_store_versions_app_store_state,
            filter_app_store_versions_platform=filter_app_store_versions_platform,
            filter_app_store_versions_app_version_state=filter_app_store_versions_app_version_state,
            filter_review_submissions_state=filter_review_submissions_state,
            filter_review_submissions_platform=filter_review_submissions_platform,
            filter_app_store_versions=filter_app_store_versions,
            filter_id=filter_id,
            exists_game_center_enabled_versions=exists_game_center_enabled_versions,
            sort=sort,
            fields_apps=fields_apps,
            fields_app_encryption_declarations=fields_app_encryption_declarations,
            fields_ci_products=fields_ci_products,
            fields_beta_groups=fields_beta_groups,
            fields_app_store_versions=fields_app_store_versions,
            fields_pre_release_versions=fields_pre_release_versions,
            fields_beta_app_localizations=fields_beta_app_localizations,
            fields_builds=fields_builds,
            fields_beta_license_agreements=fields_beta_license_agreements,
            fields_beta_app_review_details=fields_beta_app_review_details,
            fields_app_infos=fields_app_infos,
            fields_app_clips=fields_app_clips,
            fields_end_user_license_agreements=fields_end_user_license_agreements,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_subscription_groups=fields_subscription_groups,
            fields_game_center_enabled_versions=fields_game_center_enabled_versions,
            fields_app_custom_product_pages=fields_app_custom_product_pages,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_app_events=fields_app_events,
            fields_review_submissions=fields_review_submissions,
            fields_subscription_grace_periods=fields_subscription_grace_periods,
            fields_game_center_details=fields_game_center_details,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            limit=limit,
            include=include,
            limit_app_clips=limit_app_clips,
            limit_app_custom_product_pages=limit_app_custom_product_pages,
            limit_app_encryption_declarations=limit_app_encryption_declarations,
            limit_app_events=limit_app_events,
            limit_app_infos=limit_app_infos,
            limit_app_store_version_experiments_v2=limit_app_store_version_experiments_v2,
            limit_app_store_versions=limit_app_store_versions,
            limit_beta_app_localizations=limit_beta_app_localizations,
            limit_beta_groups=limit_beta_groups,
            limit_builds=limit_builds,
            limit_game_center_enabled_versions=limit_game_center_enabled_versions,
            limit_in_app_purchases=limit_in_app_purchases,
            limit_in_app_purchases_v2=limit_in_app_purchases_v2,
            limit_pre_release_versions=limit_pre_release_versions,
            limit_promoted_purchases=limit_promoted_purchases,
            limit_review_submissions=limit_review_submissions,
            limit_subscription_groups=limit_subscription_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '200': "AppsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_get_collection_with_http_info(
        self,
        filter_name: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'name'")] = None,
        filter_bundle_id: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'bundleId'")] = None,
        filter_sku: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'sku'")] = None,
        filter_app_store_versions_app_store_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreVersions.appStoreState'")] = None,
        filter_app_store_versions_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreVersions.platform'")] = None,
        filter_app_store_versions_app_version_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreVersions.appVersionState'")] = None,
        filter_review_submissions_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'reviewSubmissions.state'")] = None,
        filter_review_submissions_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'reviewSubmissions.platform'")] = None,
        filter_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'appStoreVersions'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        exists_game_center_enabled_versions: Annotated[Optional[StrictBool], Field(description="filter by existence or non-existence of related 'gameCenterEnabledVersions'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_encryption_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarations")] = None,
        fields_ci_products: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ciProducts")] = None,
        fields_beta_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaGroups")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_pre_release_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type preReleaseVersions")] = None,
        fields_beta_app_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppLocalizations")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaLicenseAgreements")] = None,
        fields_beta_app_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppReviewDetails")] = None,
        fields_app_infos: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfos")] = None,
        fields_app_clips: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClips")] = None,
        fields_end_user_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type endUserLicenseAgreements")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_subscription_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroups")] = None,
        fields_game_center_enabled_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterEnabledVersions")] = None,
        fields_app_custom_product_pages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPages")] = None,
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_app_events: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEvents")] = None,
        fields_review_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissions")] = None,
        fields_subscription_grace_periods: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGracePeriods")] = None,
        fields_game_center_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterDetails")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_clips: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appClips returned (when they are included)")] = None,
        limit_app_custom_product_pages: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appCustomProductPages returned (when they are included)")] = None,
        limit_app_encryption_declarations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEncryptionDeclarations returned (when they are included)")] = None,
        limit_app_events: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEvents returned (when they are included)")] = None,
        limit_app_infos: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appInfos returned (when they are included)")] = None,
        limit_app_store_version_experiments_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentsV2 returned (when they are included)")] = None,
        limit_app_store_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersions returned (when they are included)")] = None,
        limit_beta_app_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaAppLocalizations returned (when they are included)")] = None,
        limit_beta_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaGroups returned (when they are included)")] = None,
        limit_builds: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related builds returned (when they are included)")] = None,
        limit_game_center_enabled_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterEnabledVersions returned (when they are included)")] = None,
        limit_in_app_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchases returned (when they are included)")] = None,
        limit_in_app_purchases_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchasesV2 returned (when they are included)")] = None,
        limit_pre_release_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related preReleaseVersions returned (when they are included)")] = None,
        limit_promoted_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related promotedPurchases returned (when they are included)")] = None,
        limit_review_submissions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related reviewSubmissions returned (when they are included)")] = None,
        limit_subscription_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptionGroups returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppsResponse]:
        """apps_get_collection


        :param filter_name: filter by attribute 'name'
        :type filter_name: List[str]
        :param filter_bundle_id: filter by attribute 'bundleId'
        :type filter_bundle_id: List[str]
        :param filter_sku: filter by attribute 'sku'
        :type filter_sku: List[str]
        :param filter_app_store_versions_app_store_state: filter by attribute 'appStoreVersions.appStoreState'
        :type filter_app_store_versions_app_store_state: List[str]
        :param filter_app_store_versions_platform: filter by attribute 'appStoreVersions.platform'
        :type filter_app_store_versions_platform: List[str]
        :param filter_app_store_versions_app_version_state: filter by attribute 'appStoreVersions.appVersionState'
        :type filter_app_store_versions_app_version_state: List[str]
        :param filter_review_submissions_state: filter by attribute 'reviewSubmissions.state'
        :type filter_review_submissions_state: List[str]
        :param filter_review_submissions_platform: filter by attribute 'reviewSubmissions.platform'
        :type filter_review_submissions_platform: List[str]
        :param filter_app_store_versions: filter by id(s) of related 'appStoreVersions'
        :type filter_app_store_versions: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param exists_game_center_enabled_versions: filter by existence or non-existence of related 'gameCenterEnabledVersions'
        :type exists_game_center_enabled_versions: bool
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_encryption_declarations: the fields to include for returned resources of type appEncryptionDeclarations
        :type fields_app_encryption_declarations: List[str]
        :param fields_ci_products: the fields to include for returned resources of type ciProducts
        :type fields_ci_products: List[str]
        :param fields_beta_groups: the fields to include for returned resources of type betaGroups
        :type fields_beta_groups: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_pre_release_versions: the fields to include for returned resources of type preReleaseVersions
        :type fields_pre_release_versions: List[str]
        :param fields_beta_app_localizations: the fields to include for returned resources of type betaAppLocalizations
        :type fields_beta_app_localizations: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_license_agreements: the fields to include for returned resources of type betaLicenseAgreements
        :type fields_beta_license_agreements: List[str]
        :param fields_beta_app_review_details: the fields to include for returned resources of type betaAppReviewDetails
        :type fields_beta_app_review_details: List[str]
        :param fields_app_infos: the fields to include for returned resources of type appInfos
        :type fields_app_infos: List[str]
        :param fields_app_clips: the fields to include for returned resources of type appClips
        :type fields_app_clips: List[str]
        :param fields_end_user_license_agreements: the fields to include for returned resources of type endUserLicenseAgreements
        :type fields_end_user_license_agreements: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_subscription_groups: the fields to include for returned resources of type subscriptionGroups
        :type fields_subscription_groups: List[str]
        :param fields_game_center_enabled_versions: the fields to include for returned resources of type gameCenterEnabledVersions
        :type fields_game_center_enabled_versions: List[str]
        :param fields_app_custom_product_pages: the fields to include for returned resources of type appCustomProductPages
        :type fields_app_custom_product_pages: List[str]
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_app_events: the fields to include for returned resources of type appEvents
        :type fields_app_events: List[str]
        :param fields_review_submissions: the fields to include for returned resources of type reviewSubmissions
        :type fields_review_submissions: List[str]
        :param fields_subscription_grace_periods: the fields to include for returned resources of type subscriptionGracePeriods
        :type fields_subscription_grace_periods: List[str]
        :param fields_game_center_details: the fields to include for returned resources of type gameCenterDetails
        :type fields_game_center_details: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_clips: maximum number of related appClips returned (when they are included)
        :type limit_app_clips: int
        :param limit_app_custom_product_pages: maximum number of related appCustomProductPages returned (when they are included)
        :type limit_app_custom_product_pages: int
        :param limit_app_encryption_declarations: maximum number of related appEncryptionDeclarations returned (when they are included)
        :type limit_app_encryption_declarations: int
        :param limit_app_events: maximum number of related appEvents returned (when they are included)
        :type limit_app_events: int
        :param limit_app_infos: maximum number of related appInfos returned (when they are included)
        :type limit_app_infos: int
        :param limit_app_store_version_experiments_v2: maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
        :type limit_app_store_version_experiments_v2: int
        :param limit_app_store_versions: maximum number of related appStoreVersions returned (when they are included)
        :type limit_app_store_versions: int
        :param limit_beta_app_localizations: maximum number of related betaAppLocalizations returned (when they are included)
        :type limit_beta_app_localizations: int
        :param limit_beta_groups: maximum number of related betaGroups returned (when they are included)
        :type limit_beta_groups: int
        :param limit_builds: maximum number of related builds returned (when they are included)
        :type limit_builds: int
        :param limit_game_center_enabled_versions: maximum number of related gameCenterEnabledVersions returned (when they are included)
        :type limit_game_center_enabled_versions: int
        :param limit_in_app_purchases: maximum number of related inAppPurchases returned (when they are included)
        :type limit_in_app_purchases: int
        :param limit_in_app_purchases_v2: maximum number of related inAppPurchasesV2 returned (when they are included)
        :type limit_in_app_purchases_v2: int
        :param limit_pre_release_versions: maximum number of related preReleaseVersions returned (when they are included)
        :type limit_pre_release_versions: int
        :param limit_promoted_purchases: maximum number of related promotedPurchases returned (when they are included)
        :type limit_promoted_purchases: int
        :param limit_review_submissions: maximum number of related reviewSubmissions returned (when they are included)
        :type limit_review_submissions: int
        :param limit_subscription_groups: maximum number of related subscriptionGroups returned (when they are included)
        :type limit_subscription_groups: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_get_collection_serialize(
            filter_name=filter_name,
            filter_bundle_id=filter_bundle_id,
            filter_sku=filter_sku,
            filter_app_store_versions_app_store_state=filter_app_store_versions_app_store_state,
            filter_app_store_versions_platform=filter_app_store_versions_platform,
            filter_app_store_versions_app_version_state=filter_app_store_versions_app_version_state,
            filter_review_submissions_state=filter_review_submissions_state,
            filter_review_submissions_platform=filter_review_submissions_platform,
            filter_app_store_versions=filter_app_store_versions,
            filter_id=filter_id,
            exists_game_center_enabled_versions=exists_game_center_enabled_versions,
            sort=sort,
            fields_apps=fields_apps,
            fields_app_encryption_declarations=fields_app_encryption_declarations,
            fields_ci_products=fields_ci_products,
            fields_beta_groups=fields_beta_groups,
            fields_app_store_versions=fields_app_store_versions,
            fields_pre_release_versions=fields_pre_release_versions,
            fields_beta_app_localizations=fields_beta_app_localizations,
            fields_builds=fields_builds,
            fields_beta_license_agreements=fields_beta_license_agreements,
            fields_beta_app_review_details=fields_beta_app_review_details,
            fields_app_infos=fields_app_infos,
            fields_app_clips=fields_app_clips,
            fields_end_user_license_agreements=fields_end_user_license_agreements,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_subscription_groups=fields_subscription_groups,
            fields_game_center_enabled_versions=fields_game_center_enabled_versions,
            fields_app_custom_product_pages=fields_app_custom_product_pages,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_app_events=fields_app_events,
            fields_review_submissions=fields_review_submissions,
            fields_subscription_grace_periods=fields_subscription_grace_periods,
            fields_game_center_details=fields_game_center_details,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            limit=limit,
            include=include,
            limit_app_clips=limit_app_clips,
            limit_app_custom_product_pages=limit_app_custom_product_pages,
            limit_app_encryption_declarations=limit_app_encryption_declarations,
            limit_app_events=limit_app_events,
            limit_app_infos=limit_app_infos,
            limit_app_store_version_experiments_v2=limit_app_store_version_experiments_v2,
            limit_app_store_versions=limit_app_store_versions,
            limit_beta_app_localizations=limit_beta_app_localizations,
            limit_beta_groups=limit_beta_groups,
            limit_builds=limit_builds,
            limit_game_center_enabled_versions=limit_game_center_enabled_versions,
            limit_in_app_purchases=limit_in_app_purchases,
            limit_in_app_purchases_v2=limit_in_app_purchases_v2,
            limit_pre_release_versions=limit_pre_release_versions,
            limit_promoted_purchases=limit_promoted_purchases,
            limit_review_submissions=limit_review_submissions,
            limit_subscription_groups=limit_subscription_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '200': "AppsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_get_collection_without_preload_content(
        self,
        filter_name: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'name'")] = None,
        filter_bundle_id: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'bundleId'")] = None,
        filter_sku: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'sku'")] = None,
        filter_app_store_versions_app_store_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreVersions.appStoreState'")] = None,
        filter_app_store_versions_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreVersions.platform'")] = None,
        filter_app_store_versions_app_version_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'appStoreVersions.appVersionState'")] = None,
        filter_review_submissions_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'reviewSubmissions.state'")] = None,
        filter_review_submissions_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'reviewSubmissions.platform'")] = None,
        filter_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s) of related 'appStoreVersions'")] = None,
        filter_id: Annotated[Optional[List[StrictStr]], Field(description="filter by id(s)")] = None,
        exists_game_center_enabled_versions: Annotated[Optional[StrictBool], Field(description="filter by existence or non-existence of related 'gameCenterEnabledVersions'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_encryption_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarations")] = None,
        fields_ci_products: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ciProducts")] = None,
        fields_beta_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaGroups")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_pre_release_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type preReleaseVersions")] = None,
        fields_beta_app_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppLocalizations")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaLicenseAgreements")] = None,
        fields_beta_app_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppReviewDetails")] = None,
        fields_app_infos: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfos")] = None,
        fields_app_clips: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClips")] = None,
        fields_end_user_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type endUserLicenseAgreements")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_subscription_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroups")] = None,
        fields_game_center_enabled_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterEnabledVersions")] = None,
        fields_app_custom_product_pages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPages")] = None,
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_app_events: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEvents")] = None,
        fields_review_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissions")] = None,
        fields_subscription_grace_periods: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGracePeriods")] = None,
        fields_game_center_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterDetails")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_clips: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appClips returned (when they are included)")] = None,
        limit_app_custom_product_pages: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appCustomProductPages returned (when they are included)")] = None,
        limit_app_encryption_declarations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEncryptionDeclarations returned (when they are included)")] = None,
        limit_app_events: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEvents returned (when they are included)")] = None,
        limit_app_infos: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appInfos returned (when they are included)")] = None,
        limit_app_store_version_experiments_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentsV2 returned (when they are included)")] = None,
        limit_app_store_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersions returned (when they are included)")] = None,
        limit_beta_app_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaAppLocalizations returned (when they are included)")] = None,
        limit_beta_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaGroups returned (when they are included)")] = None,
        limit_builds: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related builds returned (when they are included)")] = None,
        limit_game_center_enabled_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterEnabledVersions returned (when they are included)")] = None,
        limit_in_app_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchases returned (when they are included)")] = None,
        limit_in_app_purchases_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchasesV2 returned (when they are included)")] = None,
        limit_pre_release_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related preReleaseVersions returned (when they are included)")] = None,
        limit_promoted_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related promotedPurchases returned (when they are included)")] = None,
        limit_review_submissions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related reviewSubmissions returned (when they are included)")] = None,
        limit_subscription_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptionGroups returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_get_collection


        :param filter_name: filter by attribute 'name'
        :type filter_name: List[str]
        :param filter_bundle_id: filter by attribute 'bundleId'
        :type filter_bundle_id: List[str]
        :param filter_sku: filter by attribute 'sku'
        :type filter_sku: List[str]
        :param filter_app_store_versions_app_store_state: filter by attribute 'appStoreVersions.appStoreState'
        :type filter_app_store_versions_app_store_state: List[str]
        :param filter_app_store_versions_platform: filter by attribute 'appStoreVersions.platform'
        :type filter_app_store_versions_platform: List[str]
        :param filter_app_store_versions_app_version_state: filter by attribute 'appStoreVersions.appVersionState'
        :type filter_app_store_versions_app_version_state: List[str]
        :param filter_review_submissions_state: filter by attribute 'reviewSubmissions.state'
        :type filter_review_submissions_state: List[str]
        :param filter_review_submissions_platform: filter by attribute 'reviewSubmissions.platform'
        :type filter_review_submissions_platform: List[str]
        :param filter_app_store_versions: filter by id(s) of related 'appStoreVersions'
        :type filter_app_store_versions: List[str]
        :param filter_id: filter by id(s)
        :type filter_id: List[str]
        :param exists_game_center_enabled_versions: filter by existence or non-existence of related 'gameCenterEnabledVersions'
        :type exists_game_center_enabled_versions: bool
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_encryption_declarations: the fields to include for returned resources of type appEncryptionDeclarations
        :type fields_app_encryption_declarations: List[str]
        :param fields_ci_products: the fields to include for returned resources of type ciProducts
        :type fields_ci_products: List[str]
        :param fields_beta_groups: the fields to include for returned resources of type betaGroups
        :type fields_beta_groups: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_pre_release_versions: the fields to include for returned resources of type preReleaseVersions
        :type fields_pre_release_versions: List[str]
        :param fields_beta_app_localizations: the fields to include for returned resources of type betaAppLocalizations
        :type fields_beta_app_localizations: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_license_agreements: the fields to include for returned resources of type betaLicenseAgreements
        :type fields_beta_license_agreements: List[str]
        :param fields_beta_app_review_details: the fields to include for returned resources of type betaAppReviewDetails
        :type fields_beta_app_review_details: List[str]
        :param fields_app_infos: the fields to include for returned resources of type appInfos
        :type fields_app_infos: List[str]
        :param fields_app_clips: the fields to include for returned resources of type appClips
        :type fields_app_clips: List[str]
        :param fields_end_user_license_agreements: the fields to include for returned resources of type endUserLicenseAgreements
        :type fields_end_user_license_agreements: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_subscription_groups: the fields to include for returned resources of type subscriptionGroups
        :type fields_subscription_groups: List[str]
        :param fields_game_center_enabled_versions: the fields to include for returned resources of type gameCenterEnabledVersions
        :type fields_game_center_enabled_versions: List[str]
        :param fields_app_custom_product_pages: the fields to include for returned resources of type appCustomProductPages
        :type fields_app_custom_product_pages: List[str]
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_app_events: the fields to include for returned resources of type appEvents
        :type fields_app_events: List[str]
        :param fields_review_submissions: the fields to include for returned resources of type reviewSubmissions
        :type fields_review_submissions: List[str]
        :param fields_subscription_grace_periods: the fields to include for returned resources of type subscriptionGracePeriods
        :type fields_subscription_grace_periods: List[str]
        :param fields_game_center_details: the fields to include for returned resources of type gameCenterDetails
        :type fields_game_center_details: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_clips: maximum number of related appClips returned (when they are included)
        :type limit_app_clips: int
        :param limit_app_custom_product_pages: maximum number of related appCustomProductPages returned (when they are included)
        :type limit_app_custom_product_pages: int
        :param limit_app_encryption_declarations: maximum number of related appEncryptionDeclarations returned (when they are included)
        :type limit_app_encryption_declarations: int
        :param limit_app_events: maximum number of related appEvents returned (when they are included)
        :type limit_app_events: int
        :param limit_app_infos: maximum number of related appInfos returned (when they are included)
        :type limit_app_infos: int
        :param limit_app_store_version_experiments_v2: maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
        :type limit_app_store_version_experiments_v2: int
        :param limit_app_store_versions: maximum number of related appStoreVersions returned (when they are included)
        :type limit_app_store_versions: int
        :param limit_beta_app_localizations: maximum number of related betaAppLocalizations returned (when they are included)
        :type limit_beta_app_localizations: int
        :param limit_beta_groups: maximum number of related betaGroups returned (when they are included)
        :type limit_beta_groups: int
        :param limit_builds: maximum number of related builds returned (when they are included)
        :type limit_builds: int
        :param limit_game_center_enabled_versions: maximum number of related gameCenterEnabledVersions returned (when they are included)
        :type limit_game_center_enabled_versions: int
        :param limit_in_app_purchases: maximum number of related inAppPurchases returned (when they are included)
        :type limit_in_app_purchases: int
        :param limit_in_app_purchases_v2: maximum number of related inAppPurchasesV2 returned (when they are included)
        :type limit_in_app_purchases_v2: int
        :param limit_pre_release_versions: maximum number of related preReleaseVersions returned (when they are included)
        :type limit_pre_release_versions: int
        :param limit_promoted_purchases: maximum number of related promotedPurchases returned (when they are included)
        :type limit_promoted_purchases: int
        :param limit_review_submissions: maximum number of related reviewSubmissions returned (when they are included)
        :type limit_review_submissions: int
        :param limit_subscription_groups: maximum number of related subscriptionGroups returned (when they are included)
        :type limit_subscription_groups: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_get_collection_serialize(
            filter_name=filter_name,
            filter_bundle_id=filter_bundle_id,
            filter_sku=filter_sku,
            filter_app_store_versions_app_store_state=filter_app_store_versions_app_store_state,
            filter_app_store_versions_platform=filter_app_store_versions_platform,
            filter_app_store_versions_app_version_state=filter_app_store_versions_app_version_state,
            filter_review_submissions_state=filter_review_submissions_state,
            filter_review_submissions_platform=filter_review_submissions_platform,
            filter_app_store_versions=filter_app_store_versions,
            filter_id=filter_id,
            exists_game_center_enabled_versions=exists_game_center_enabled_versions,
            sort=sort,
            fields_apps=fields_apps,
            fields_app_encryption_declarations=fields_app_encryption_declarations,
            fields_ci_products=fields_ci_products,
            fields_beta_groups=fields_beta_groups,
            fields_app_store_versions=fields_app_store_versions,
            fields_pre_release_versions=fields_pre_release_versions,
            fields_beta_app_localizations=fields_beta_app_localizations,
            fields_builds=fields_builds,
            fields_beta_license_agreements=fields_beta_license_agreements,
            fields_beta_app_review_details=fields_beta_app_review_details,
            fields_app_infos=fields_app_infos,
            fields_app_clips=fields_app_clips,
            fields_end_user_license_agreements=fields_end_user_license_agreements,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_subscription_groups=fields_subscription_groups,
            fields_game_center_enabled_versions=fields_game_center_enabled_versions,
            fields_app_custom_product_pages=fields_app_custom_product_pages,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_app_events=fields_app_events,
            fields_review_submissions=fields_review_submissions,
            fields_subscription_grace_periods=fields_subscription_grace_periods,
            fields_game_center_details=fields_game_center_details,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            limit=limit,
            include=include,
            limit_app_clips=limit_app_clips,
            limit_app_custom_product_pages=limit_app_custom_product_pages,
            limit_app_encryption_declarations=limit_app_encryption_declarations,
            limit_app_events=limit_app_events,
            limit_app_infos=limit_app_infos,
            limit_app_store_version_experiments_v2=limit_app_store_version_experiments_v2,
            limit_app_store_versions=limit_app_store_versions,
            limit_beta_app_localizations=limit_beta_app_localizations,
            limit_beta_groups=limit_beta_groups,
            limit_builds=limit_builds,
            limit_game_center_enabled_versions=limit_game_center_enabled_versions,
            limit_in_app_purchases=limit_in_app_purchases,
            limit_in_app_purchases_v2=limit_in_app_purchases_v2,
            limit_pre_release_versions=limit_pre_release_versions,
            limit_promoted_purchases=limit_promoted_purchases,
            limit_review_submissions=limit_review_submissions,
            limit_subscription_groups=limit_subscription_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '200': "AppsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_get_collection_serialize(
        self,
        filter_name,
        filter_bundle_id,
        filter_sku,
        filter_app_store_versions_app_store_state,
        filter_app_store_versions_platform,
        filter_app_store_versions_app_version_state,
        filter_review_submissions_state,
        filter_review_submissions_platform,
        filter_app_store_versions,
        filter_id,
        exists_game_center_enabled_versions,
        sort,
        fields_apps,
        fields_app_encryption_declarations,
        fields_ci_products,
        fields_beta_groups,
        fields_app_store_versions,
        fields_pre_release_versions,
        fields_beta_app_localizations,
        fields_builds,
        fields_beta_license_agreements,
        fields_beta_app_review_details,
        fields_app_infos,
        fields_app_clips,
        fields_end_user_license_agreements,
        fields_in_app_purchases,
        fields_subscription_groups,
        fields_game_center_enabled_versions,
        fields_app_custom_product_pages,
        fields_promoted_purchases,
        fields_app_events,
        fields_review_submissions,
        fields_subscription_grace_periods,
        fields_game_center_details,
        fields_app_store_version_experiments,
        limit,
        include,
        limit_app_clips,
        limit_app_custom_product_pages,
        limit_app_encryption_declarations,
        limit_app_events,
        limit_app_infos,
        limit_app_store_version_experiments_v2,
        limit_app_store_versions,
        limit_beta_app_localizations,
        limit_beta_groups,
        limit_builds,
        limit_game_center_enabled_versions,
        limit_in_app_purchases,
        limit_in_app_purchases_v2,
        limit_pre_release_versions,
        limit_promoted_purchases,
        limit_review_submissions,
        limit_subscription_groups,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[name]': 'csv',
            'filter[bundleId]': 'csv',
            'filter[sku]': 'csv',
            'filter[appStoreVersions.appStoreState]': 'csv',
            'filter[appStoreVersions.platform]': 'csv',
            'filter[appStoreVersions.appVersionState]': 'csv',
            'filter[reviewSubmissions.state]': 'csv',
            'filter[reviewSubmissions.platform]': 'csv',
            'filter[appStoreVersions]': 'csv',
            'filter[id]': 'csv',
            'sort': 'csv',
            'fields[apps]': 'csv',
            'fields[appEncryptionDeclarations]': 'csv',
            'fields[ciProducts]': 'csv',
            'fields[betaGroups]': 'csv',
            'fields[appStoreVersions]': 'csv',
            'fields[preReleaseVersions]': 'csv',
            'fields[betaAppLocalizations]': 'csv',
            'fields[builds]': 'csv',
            'fields[betaLicenseAgreements]': 'csv',
            'fields[betaAppReviewDetails]': 'csv',
            'fields[appInfos]': 'csv',
            'fields[appClips]': 'csv',
            'fields[endUserLicenseAgreements]': 'csv',
            'fields[inAppPurchases]': 'csv',
            'fields[subscriptionGroups]': 'csv',
            'fields[gameCenterEnabledVersions]': 'csv',
            'fields[appCustomProductPages]': 'csv',
            'fields[promotedPurchases]': 'csv',
            'fields[appEvents]': 'csv',
            'fields[reviewSubmissions]': 'csv',
            'fields[subscriptionGracePeriods]': 'csv',
            'fields[gameCenterDetails]': 'csv',
            'fields[appStoreVersionExperiments]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if filter_name is not None:
            
            _query_params.append(('filter[name]', filter_name))
            
        if filter_bundle_id is not None:
            
            _query_params.append(('filter[bundleId]', filter_bundle_id))
            
        if filter_sku is not None:
            
            _query_params.append(('filter[sku]', filter_sku))
            
        if filter_app_store_versions_app_store_state is not None:
            
            _query_params.append(('filter[appStoreVersions.appStoreState]', filter_app_store_versions_app_store_state))
            
        if filter_app_store_versions_platform is not None:
            
            _query_params.append(('filter[appStoreVersions.platform]', filter_app_store_versions_platform))
            
        if filter_app_store_versions_app_version_state is not None:
            
            _query_params.append(('filter[appStoreVersions.appVersionState]', filter_app_store_versions_app_version_state))
            
        if filter_review_submissions_state is not None:
            
            _query_params.append(('filter[reviewSubmissions.state]', filter_review_submissions_state))
            
        if filter_review_submissions_platform is not None:
            
            _query_params.append(('filter[reviewSubmissions.platform]', filter_review_submissions_platform))
            
        if filter_app_store_versions is not None:
            
            _query_params.append(('filter[appStoreVersions]', filter_app_store_versions))
            
        if filter_id is not None:
            
            _query_params.append(('filter[id]', filter_id))
            
        if exists_game_center_enabled_versions is not None:
            
            _query_params.append(('exists[gameCenterEnabledVersions]', exists_game_center_enabled_versions))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_app_encryption_declarations is not None:
            
            _query_params.append(('fields[appEncryptionDeclarations]', fields_app_encryption_declarations))
            
        if fields_ci_products is not None:
            
            _query_params.append(('fields[ciProducts]', fields_ci_products))
            
        if fields_beta_groups is not None:
            
            _query_params.append(('fields[betaGroups]', fields_beta_groups))
            
        if fields_app_store_versions is not None:
            
            _query_params.append(('fields[appStoreVersions]', fields_app_store_versions))
            
        if fields_pre_release_versions is not None:
            
            _query_params.append(('fields[preReleaseVersions]', fields_pre_release_versions))
            
        if fields_beta_app_localizations is not None:
            
            _query_params.append(('fields[betaAppLocalizations]', fields_beta_app_localizations))
            
        if fields_builds is not None:
            
            _query_params.append(('fields[builds]', fields_builds))
            
        if fields_beta_license_agreements is not None:
            
            _query_params.append(('fields[betaLicenseAgreements]', fields_beta_license_agreements))
            
        if fields_beta_app_review_details is not None:
            
            _query_params.append(('fields[betaAppReviewDetails]', fields_beta_app_review_details))
            
        if fields_app_infos is not None:
            
            _query_params.append(('fields[appInfos]', fields_app_infos))
            
        if fields_app_clips is not None:
            
            _query_params.append(('fields[appClips]', fields_app_clips))
            
        if fields_end_user_license_agreements is not None:
            
            _query_params.append(('fields[endUserLicenseAgreements]', fields_end_user_license_agreements))
            
        if fields_in_app_purchases is not None:
            
            _query_params.append(('fields[inAppPurchases]', fields_in_app_purchases))
            
        if fields_subscription_groups is not None:
            
            _query_params.append(('fields[subscriptionGroups]', fields_subscription_groups))
            
        if fields_game_center_enabled_versions is not None:
            
            _query_params.append(('fields[gameCenterEnabledVersions]', fields_game_center_enabled_versions))
            
        if fields_app_custom_product_pages is not None:
            
            _query_params.append(('fields[appCustomProductPages]', fields_app_custom_product_pages))
            
        if fields_promoted_purchases is not None:
            
            _query_params.append(('fields[promotedPurchases]', fields_promoted_purchases))
            
        if fields_app_events is not None:
            
            _query_params.append(('fields[appEvents]', fields_app_events))
            
        if fields_review_submissions is not None:
            
            _query_params.append(('fields[reviewSubmissions]', fields_review_submissions))
            
        if fields_subscription_grace_periods is not None:
            
            _query_params.append(('fields[subscriptionGracePeriods]', fields_subscription_grace_periods))
            
        if fields_game_center_details is not None:
            
            _query_params.append(('fields[gameCenterDetails]', fields_game_center_details))
            
        if fields_app_store_version_experiments is not None:
            
            _query_params.append(('fields[appStoreVersionExperiments]', fields_app_store_version_experiments))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_app_clips is not None:
            
            _query_params.append(('limit[appClips]', limit_app_clips))
            
        if limit_app_custom_product_pages is not None:
            
            _query_params.append(('limit[appCustomProductPages]', limit_app_custom_product_pages))
            
        if limit_app_encryption_declarations is not None:
            
            _query_params.append(('limit[appEncryptionDeclarations]', limit_app_encryption_declarations))
            
        if limit_app_events is not None:
            
            _query_params.append(('limit[appEvents]', limit_app_events))
            
        if limit_app_infos is not None:
            
            _query_params.append(('limit[appInfos]', limit_app_infos))
            
        if limit_app_store_version_experiments_v2 is not None:
            
            _query_params.append(('limit[appStoreVersionExperimentsV2]', limit_app_store_version_experiments_v2))
            
        if limit_app_store_versions is not None:
            
            _query_params.append(('limit[appStoreVersions]', limit_app_store_versions))
            
        if limit_beta_app_localizations is not None:
            
            _query_params.append(('limit[betaAppLocalizations]', limit_beta_app_localizations))
            
        if limit_beta_groups is not None:
            
            _query_params.append(('limit[betaGroups]', limit_beta_groups))
            
        if limit_builds is not None:
            
            _query_params.append(('limit[builds]', limit_builds))
            
        if limit_game_center_enabled_versions is not None:
            
            _query_params.append(('limit[gameCenterEnabledVersions]', limit_game_center_enabled_versions))
            
        if limit_in_app_purchases is not None:
            
            _query_params.append(('limit[inAppPurchases]', limit_in_app_purchases))
            
        if limit_in_app_purchases_v2 is not None:
            
            _query_params.append(('limit[inAppPurchasesV2]', limit_in_app_purchases_v2))
            
        if limit_pre_release_versions is not None:
            
            _query_params.append(('limit[preReleaseVersions]', limit_pre_release_versions))
            
        if limit_promoted_purchases is not None:
            
            _query_params.append(('limit[promotedPurchases]', limit_promoted_purchases))
            
        if limit_review_submissions is not None:
            
            _query_params.append(('limit[reviewSubmissions]', limit_review_submissions))
            
        if limit_subscription_groups is not None:
            
            _query_params.append(('limit[subscriptionGroups]', limit_subscription_groups))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_get_instance(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_encryption_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarations")] = None,
        fields_ci_products: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ciProducts")] = None,
        fields_beta_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaGroups")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_pre_release_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type preReleaseVersions")] = None,
        fields_beta_app_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppLocalizations")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaLicenseAgreements")] = None,
        fields_beta_app_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppReviewDetails")] = None,
        fields_app_infos: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfos")] = None,
        fields_app_clips: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClips")] = None,
        fields_end_user_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type endUserLicenseAgreements")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_subscription_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroups")] = None,
        fields_game_center_enabled_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterEnabledVersions")] = None,
        fields_app_custom_product_pages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPages")] = None,
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_app_events: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEvents")] = None,
        fields_review_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissions")] = None,
        fields_subscription_grace_periods: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGracePeriods")] = None,
        fields_game_center_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterDetails")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_clips: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appClips returned (when they are included)")] = None,
        limit_app_custom_product_pages: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appCustomProductPages returned (when they are included)")] = None,
        limit_app_encryption_declarations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEncryptionDeclarations returned (when they are included)")] = None,
        limit_app_events: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEvents returned (when they are included)")] = None,
        limit_app_infos: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appInfos returned (when they are included)")] = None,
        limit_app_store_version_experiments_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentsV2 returned (when they are included)")] = None,
        limit_app_store_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersions returned (when they are included)")] = None,
        limit_beta_app_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaAppLocalizations returned (when they are included)")] = None,
        limit_beta_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaGroups returned (when they are included)")] = None,
        limit_builds: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related builds returned (when they are included)")] = None,
        limit_game_center_enabled_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterEnabledVersions returned (when they are included)")] = None,
        limit_in_app_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchases returned (when they are included)")] = None,
        limit_in_app_purchases_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchasesV2 returned (when they are included)")] = None,
        limit_pre_release_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related preReleaseVersions returned (when they are included)")] = None,
        limit_promoted_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related promotedPurchases returned (when they are included)")] = None,
        limit_review_submissions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related reviewSubmissions returned (when they are included)")] = None,
        limit_subscription_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptionGroups returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppResponse:
        """apps_get_instance


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_encryption_declarations: the fields to include for returned resources of type appEncryptionDeclarations
        :type fields_app_encryption_declarations: List[str]
        :param fields_ci_products: the fields to include for returned resources of type ciProducts
        :type fields_ci_products: List[str]
        :param fields_beta_groups: the fields to include for returned resources of type betaGroups
        :type fields_beta_groups: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_pre_release_versions: the fields to include for returned resources of type preReleaseVersions
        :type fields_pre_release_versions: List[str]
        :param fields_beta_app_localizations: the fields to include for returned resources of type betaAppLocalizations
        :type fields_beta_app_localizations: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_license_agreements: the fields to include for returned resources of type betaLicenseAgreements
        :type fields_beta_license_agreements: List[str]
        :param fields_beta_app_review_details: the fields to include for returned resources of type betaAppReviewDetails
        :type fields_beta_app_review_details: List[str]
        :param fields_app_infos: the fields to include for returned resources of type appInfos
        :type fields_app_infos: List[str]
        :param fields_app_clips: the fields to include for returned resources of type appClips
        :type fields_app_clips: List[str]
        :param fields_end_user_license_agreements: the fields to include for returned resources of type endUserLicenseAgreements
        :type fields_end_user_license_agreements: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_subscription_groups: the fields to include for returned resources of type subscriptionGroups
        :type fields_subscription_groups: List[str]
        :param fields_game_center_enabled_versions: the fields to include for returned resources of type gameCenterEnabledVersions
        :type fields_game_center_enabled_versions: List[str]
        :param fields_app_custom_product_pages: the fields to include for returned resources of type appCustomProductPages
        :type fields_app_custom_product_pages: List[str]
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_app_events: the fields to include for returned resources of type appEvents
        :type fields_app_events: List[str]
        :param fields_review_submissions: the fields to include for returned resources of type reviewSubmissions
        :type fields_review_submissions: List[str]
        :param fields_subscription_grace_periods: the fields to include for returned resources of type subscriptionGracePeriods
        :type fields_subscription_grace_periods: List[str]
        :param fields_game_center_details: the fields to include for returned resources of type gameCenterDetails
        :type fields_game_center_details: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_clips: maximum number of related appClips returned (when they are included)
        :type limit_app_clips: int
        :param limit_app_custom_product_pages: maximum number of related appCustomProductPages returned (when they are included)
        :type limit_app_custom_product_pages: int
        :param limit_app_encryption_declarations: maximum number of related appEncryptionDeclarations returned (when they are included)
        :type limit_app_encryption_declarations: int
        :param limit_app_events: maximum number of related appEvents returned (when they are included)
        :type limit_app_events: int
        :param limit_app_infos: maximum number of related appInfos returned (when they are included)
        :type limit_app_infos: int
        :param limit_app_store_version_experiments_v2: maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
        :type limit_app_store_version_experiments_v2: int
        :param limit_app_store_versions: maximum number of related appStoreVersions returned (when they are included)
        :type limit_app_store_versions: int
        :param limit_beta_app_localizations: maximum number of related betaAppLocalizations returned (when they are included)
        :type limit_beta_app_localizations: int
        :param limit_beta_groups: maximum number of related betaGroups returned (when they are included)
        :type limit_beta_groups: int
        :param limit_builds: maximum number of related builds returned (when they are included)
        :type limit_builds: int
        :param limit_game_center_enabled_versions: maximum number of related gameCenterEnabledVersions returned (when they are included)
        :type limit_game_center_enabled_versions: int
        :param limit_in_app_purchases: maximum number of related inAppPurchases returned (when they are included)
        :type limit_in_app_purchases: int
        :param limit_in_app_purchases_v2: maximum number of related inAppPurchasesV2 returned (when they are included)
        :type limit_in_app_purchases_v2: int
        :param limit_pre_release_versions: maximum number of related preReleaseVersions returned (when they are included)
        :type limit_pre_release_versions: int
        :param limit_promoted_purchases: maximum number of related promotedPurchases returned (when they are included)
        :type limit_promoted_purchases: int
        :param limit_review_submissions: maximum number of related reviewSubmissions returned (when they are included)
        :type limit_review_submissions: int
        :param limit_subscription_groups: maximum number of related subscriptionGroups returned (when they are included)
        :type limit_subscription_groups: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_get_instance_serialize(
            id=id,
            fields_apps=fields_apps,
            fields_app_encryption_declarations=fields_app_encryption_declarations,
            fields_ci_products=fields_ci_products,
            fields_beta_groups=fields_beta_groups,
            fields_app_store_versions=fields_app_store_versions,
            fields_pre_release_versions=fields_pre_release_versions,
            fields_beta_app_localizations=fields_beta_app_localizations,
            fields_builds=fields_builds,
            fields_beta_license_agreements=fields_beta_license_agreements,
            fields_beta_app_review_details=fields_beta_app_review_details,
            fields_app_infos=fields_app_infos,
            fields_app_clips=fields_app_clips,
            fields_end_user_license_agreements=fields_end_user_license_agreements,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_subscription_groups=fields_subscription_groups,
            fields_game_center_enabled_versions=fields_game_center_enabled_versions,
            fields_app_custom_product_pages=fields_app_custom_product_pages,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_app_events=fields_app_events,
            fields_review_submissions=fields_review_submissions,
            fields_subscription_grace_periods=fields_subscription_grace_periods,
            fields_game_center_details=fields_game_center_details,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            include=include,
            limit_app_clips=limit_app_clips,
            limit_app_custom_product_pages=limit_app_custom_product_pages,
            limit_app_encryption_declarations=limit_app_encryption_declarations,
            limit_app_events=limit_app_events,
            limit_app_infos=limit_app_infos,
            limit_app_store_version_experiments_v2=limit_app_store_version_experiments_v2,
            limit_app_store_versions=limit_app_store_versions,
            limit_beta_app_localizations=limit_beta_app_localizations,
            limit_beta_groups=limit_beta_groups,
            limit_builds=limit_builds,
            limit_game_center_enabled_versions=limit_game_center_enabled_versions,
            limit_in_app_purchases=limit_in_app_purchases,
            limit_in_app_purchases_v2=limit_in_app_purchases_v2,
            limit_pre_release_versions=limit_pre_release_versions,
            limit_promoted_purchases=limit_promoted_purchases,
            limit_review_submissions=limit_review_submissions,
            limit_subscription_groups=limit_subscription_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_get_instance_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_encryption_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarations")] = None,
        fields_ci_products: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ciProducts")] = None,
        fields_beta_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaGroups")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_pre_release_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type preReleaseVersions")] = None,
        fields_beta_app_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppLocalizations")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaLicenseAgreements")] = None,
        fields_beta_app_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppReviewDetails")] = None,
        fields_app_infos: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfos")] = None,
        fields_app_clips: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClips")] = None,
        fields_end_user_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type endUserLicenseAgreements")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_subscription_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroups")] = None,
        fields_game_center_enabled_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterEnabledVersions")] = None,
        fields_app_custom_product_pages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPages")] = None,
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_app_events: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEvents")] = None,
        fields_review_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissions")] = None,
        fields_subscription_grace_periods: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGracePeriods")] = None,
        fields_game_center_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterDetails")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_clips: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appClips returned (when they are included)")] = None,
        limit_app_custom_product_pages: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appCustomProductPages returned (when they are included)")] = None,
        limit_app_encryption_declarations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEncryptionDeclarations returned (when they are included)")] = None,
        limit_app_events: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEvents returned (when they are included)")] = None,
        limit_app_infos: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appInfos returned (when they are included)")] = None,
        limit_app_store_version_experiments_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentsV2 returned (when they are included)")] = None,
        limit_app_store_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersions returned (when they are included)")] = None,
        limit_beta_app_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaAppLocalizations returned (when they are included)")] = None,
        limit_beta_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaGroups returned (when they are included)")] = None,
        limit_builds: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related builds returned (when they are included)")] = None,
        limit_game_center_enabled_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterEnabledVersions returned (when they are included)")] = None,
        limit_in_app_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchases returned (when they are included)")] = None,
        limit_in_app_purchases_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchasesV2 returned (when they are included)")] = None,
        limit_pre_release_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related preReleaseVersions returned (when they are included)")] = None,
        limit_promoted_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related promotedPurchases returned (when they are included)")] = None,
        limit_review_submissions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related reviewSubmissions returned (when they are included)")] = None,
        limit_subscription_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptionGroups returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppResponse]:
        """apps_get_instance


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_encryption_declarations: the fields to include for returned resources of type appEncryptionDeclarations
        :type fields_app_encryption_declarations: List[str]
        :param fields_ci_products: the fields to include for returned resources of type ciProducts
        :type fields_ci_products: List[str]
        :param fields_beta_groups: the fields to include for returned resources of type betaGroups
        :type fields_beta_groups: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_pre_release_versions: the fields to include for returned resources of type preReleaseVersions
        :type fields_pre_release_versions: List[str]
        :param fields_beta_app_localizations: the fields to include for returned resources of type betaAppLocalizations
        :type fields_beta_app_localizations: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_license_agreements: the fields to include for returned resources of type betaLicenseAgreements
        :type fields_beta_license_agreements: List[str]
        :param fields_beta_app_review_details: the fields to include for returned resources of type betaAppReviewDetails
        :type fields_beta_app_review_details: List[str]
        :param fields_app_infos: the fields to include for returned resources of type appInfos
        :type fields_app_infos: List[str]
        :param fields_app_clips: the fields to include for returned resources of type appClips
        :type fields_app_clips: List[str]
        :param fields_end_user_license_agreements: the fields to include for returned resources of type endUserLicenseAgreements
        :type fields_end_user_license_agreements: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_subscription_groups: the fields to include for returned resources of type subscriptionGroups
        :type fields_subscription_groups: List[str]
        :param fields_game_center_enabled_versions: the fields to include for returned resources of type gameCenterEnabledVersions
        :type fields_game_center_enabled_versions: List[str]
        :param fields_app_custom_product_pages: the fields to include for returned resources of type appCustomProductPages
        :type fields_app_custom_product_pages: List[str]
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_app_events: the fields to include for returned resources of type appEvents
        :type fields_app_events: List[str]
        :param fields_review_submissions: the fields to include for returned resources of type reviewSubmissions
        :type fields_review_submissions: List[str]
        :param fields_subscription_grace_periods: the fields to include for returned resources of type subscriptionGracePeriods
        :type fields_subscription_grace_periods: List[str]
        :param fields_game_center_details: the fields to include for returned resources of type gameCenterDetails
        :type fields_game_center_details: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_clips: maximum number of related appClips returned (when they are included)
        :type limit_app_clips: int
        :param limit_app_custom_product_pages: maximum number of related appCustomProductPages returned (when they are included)
        :type limit_app_custom_product_pages: int
        :param limit_app_encryption_declarations: maximum number of related appEncryptionDeclarations returned (when they are included)
        :type limit_app_encryption_declarations: int
        :param limit_app_events: maximum number of related appEvents returned (when they are included)
        :type limit_app_events: int
        :param limit_app_infos: maximum number of related appInfos returned (when they are included)
        :type limit_app_infos: int
        :param limit_app_store_version_experiments_v2: maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
        :type limit_app_store_version_experiments_v2: int
        :param limit_app_store_versions: maximum number of related appStoreVersions returned (when they are included)
        :type limit_app_store_versions: int
        :param limit_beta_app_localizations: maximum number of related betaAppLocalizations returned (when they are included)
        :type limit_beta_app_localizations: int
        :param limit_beta_groups: maximum number of related betaGroups returned (when they are included)
        :type limit_beta_groups: int
        :param limit_builds: maximum number of related builds returned (when they are included)
        :type limit_builds: int
        :param limit_game_center_enabled_versions: maximum number of related gameCenterEnabledVersions returned (when they are included)
        :type limit_game_center_enabled_versions: int
        :param limit_in_app_purchases: maximum number of related inAppPurchases returned (when they are included)
        :type limit_in_app_purchases: int
        :param limit_in_app_purchases_v2: maximum number of related inAppPurchasesV2 returned (when they are included)
        :type limit_in_app_purchases_v2: int
        :param limit_pre_release_versions: maximum number of related preReleaseVersions returned (when they are included)
        :type limit_pre_release_versions: int
        :param limit_promoted_purchases: maximum number of related promotedPurchases returned (when they are included)
        :type limit_promoted_purchases: int
        :param limit_review_submissions: maximum number of related reviewSubmissions returned (when they are included)
        :type limit_review_submissions: int
        :param limit_subscription_groups: maximum number of related subscriptionGroups returned (when they are included)
        :type limit_subscription_groups: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_get_instance_serialize(
            id=id,
            fields_apps=fields_apps,
            fields_app_encryption_declarations=fields_app_encryption_declarations,
            fields_ci_products=fields_ci_products,
            fields_beta_groups=fields_beta_groups,
            fields_app_store_versions=fields_app_store_versions,
            fields_pre_release_versions=fields_pre_release_versions,
            fields_beta_app_localizations=fields_beta_app_localizations,
            fields_builds=fields_builds,
            fields_beta_license_agreements=fields_beta_license_agreements,
            fields_beta_app_review_details=fields_beta_app_review_details,
            fields_app_infos=fields_app_infos,
            fields_app_clips=fields_app_clips,
            fields_end_user_license_agreements=fields_end_user_license_agreements,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_subscription_groups=fields_subscription_groups,
            fields_game_center_enabled_versions=fields_game_center_enabled_versions,
            fields_app_custom_product_pages=fields_app_custom_product_pages,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_app_events=fields_app_events,
            fields_review_submissions=fields_review_submissions,
            fields_subscription_grace_periods=fields_subscription_grace_periods,
            fields_game_center_details=fields_game_center_details,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            include=include,
            limit_app_clips=limit_app_clips,
            limit_app_custom_product_pages=limit_app_custom_product_pages,
            limit_app_encryption_declarations=limit_app_encryption_declarations,
            limit_app_events=limit_app_events,
            limit_app_infos=limit_app_infos,
            limit_app_store_version_experiments_v2=limit_app_store_version_experiments_v2,
            limit_app_store_versions=limit_app_store_versions,
            limit_beta_app_localizations=limit_beta_app_localizations,
            limit_beta_groups=limit_beta_groups,
            limit_builds=limit_builds,
            limit_game_center_enabled_versions=limit_game_center_enabled_versions,
            limit_in_app_purchases=limit_in_app_purchases,
            limit_in_app_purchases_v2=limit_in_app_purchases_v2,
            limit_pre_release_versions=limit_pre_release_versions,
            limit_promoted_purchases=limit_promoted_purchases,
            limit_review_submissions=limit_review_submissions,
            limit_subscription_groups=limit_subscription_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_get_instance_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_app_encryption_declarations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEncryptionDeclarations")] = None,
        fields_ci_products: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type ciProducts")] = None,
        fields_beta_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaGroups")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_pre_release_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type preReleaseVersions")] = None,
        fields_beta_app_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppLocalizations")] = None,
        fields_builds: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type builds")] = None,
        fields_beta_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaLicenseAgreements")] = None,
        fields_beta_app_review_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type betaAppReviewDetails")] = None,
        fields_app_infos: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appInfos")] = None,
        fields_app_clips: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appClips")] = None,
        fields_end_user_license_agreements: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type endUserLicenseAgreements")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_subscription_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroups")] = None,
        fields_game_center_enabled_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterEnabledVersions")] = None,
        fields_app_custom_product_pages: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appCustomProductPages")] = None,
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_app_events: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appEvents")] = None,
        fields_review_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissions")] = None,
        fields_subscription_grace_periods: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGracePeriods")] = None,
        fields_game_center_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type gameCenterDetails")] = None,
        fields_app_store_version_experiments: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersionExperiments")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_app_clips: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appClips returned (when they are included)")] = None,
        limit_app_custom_product_pages: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appCustomProductPages returned (when they are included)")] = None,
        limit_app_encryption_declarations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEncryptionDeclarations returned (when they are included)")] = None,
        limit_app_events: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appEvents returned (when they are included)")] = None,
        limit_app_infos: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appInfos returned (when they are included)")] = None,
        limit_app_store_version_experiments_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersionExperimentsV2 returned (when they are included)")] = None,
        limit_app_store_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related appStoreVersions returned (when they are included)")] = None,
        limit_beta_app_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaAppLocalizations returned (when they are included)")] = None,
        limit_beta_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related betaGroups returned (when they are included)")] = None,
        limit_builds: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related builds returned (when they are included)")] = None,
        limit_game_center_enabled_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related gameCenterEnabledVersions returned (when they are included)")] = None,
        limit_in_app_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchases returned (when they are included)")] = None,
        limit_in_app_purchases_v2: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchasesV2 returned (when they are included)")] = None,
        limit_pre_release_versions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related preReleaseVersions returned (when they are included)")] = None,
        limit_promoted_purchases: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related promotedPurchases returned (when they are included)")] = None,
        limit_review_submissions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related reviewSubmissions returned (when they are included)")] = None,
        limit_subscription_groups: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptionGroups returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_get_instance


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_app_encryption_declarations: the fields to include for returned resources of type appEncryptionDeclarations
        :type fields_app_encryption_declarations: List[str]
        :param fields_ci_products: the fields to include for returned resources of type ciProducts
        :type fields_ci_products: List[str]
        :param fields_beta_groups: the fields to include for returned resources of type betaGroups
        :type fields_beta_groups: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_pre_release_versions: the fields to include for returned resources of type preReleaseVersions
        :type fields_pre_release_versions: List[str]
        :param fields_beta_app_localizations: the fields to include for returned resources of type betaAppLocalizations
        :type fields_beta_app_localizations: List[str]
        :param fields_builds: the fields to include for returned resources of type builds
        :type fields_builds: List[str]
        :param fields_beta_license_agreements: the fields to include for returned resources of type betaLicenseAgreements
        :type fields_beta_license_agreements: List[str]
        :param fields_beta_app_review_details: the fields to include for returned resources of type betaAppReviewDetails
        :type fields_beta_app_review_details: List[str]
        :param fields_app_infos: the fields to include for returned resources of type appInfos
        :type fields_app_infos: List[str]
        :param fields_app_clips: the fields to include for returned resources of type appClips
        :type fields_app_clips: List[str]
        :param fields_end_user_license_agreements: the fields to include for returned resources of type endUserLicenseAgreements
        :type fields_end_user_license_agreements: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_subscription_groups: the fields to include for returned resources of type subscriptionGroups
        :type fields_subscription_groups: List[str]
        :param fields_game_center_enabled_versions: the fields to include for returned resources of type gameCenterEnabledVersions
        :type fields_game_center_enabled_versions: List[str]
        :param fields_app_custom_product_pages: the fields to include for returned resources of type appCustomProductPages
        :type fields_app_custom_product_pages: List[str]
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_app_events: the fields to include for returned resources of type appEvents
        :type fields_app_events: List[str]
        :param fields_review_submissions: the fields to include for returned resources of type reviewSubmissions
        :type fields_review_submissions: List[str]
        :param fields_subscription_grace_periods: the fields to include for returned resources of type subscriptionGracePeriods
        :type fields_subscription_grace_periods: List[str]
        :param fields_game_center_details: the fields to include for returned resources of type gameCenterDetails
        :type fields_game_center_details: List[str]
        :param fields_app_store_version_experiments: the fields to include for returned resources of type appStoreVersionExperiments
        :type fields_app_store_version_experiments: List[str]
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_app_clips: maximum number of related appClips returned (when they are included)
        :type limit_app_clips: int
        :param limit_app_custom_product_pages: maximum number of related appCustomProductPages returned (when they are included)
        :type limit_app_custom_product_pages: int
        :param limit_app_encryption_declarations: maximum number of related appEncryptionDeclarations returned (when they are included)
        :type limit_app_encryption_declarations: int
        :param limit_app_events: maximum number of related appEvents returned (when they are included)
        :type limit_app_events: int
        :param limit_app_infos: maximum number of related appInfos returned (when they are included)
        :type limit_app_infos: int
        :param limit_app_store_version_experiments_v2: maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
        :type limit_app_store_version_experiments_v2: int
        :param limit_app_store_versions: maximum number of related appStoreVersions returned (when they are included)
        :type limit_app_store_versions: int
        :param limit_beta_app_localizations: maximum number of related betaAppLocalizations returned (when they are included)
        :type limit_beta_app_localizations: int
        :param limit_beta_groups: maximum number of related betaGroups returned (when they are included)
        :type limit_beta_groups: int
        :param limit_builds: maximum number of related builds returned (when they are included)
        :type limit_builds: int
        :param limit_game_center_enabled_versions: maximum number of related gameCenterEnabledVersions returned (when they are included)
        :type limit_game_center_enabled_versions: int
        :param limit_in_app_purchases: maximum number of related inAppPurchases returned (when they are included)
        :type limit_in_app_purchases: int
        :param limit_in_app_purchases_v2: maximum number of related inAppPurchasesV2 returned (when they are included)
        :type limit_in_app_purchases_v2: int
        :param limit_pre_release_versions: maximum number of related preReleaseVersions returned (when they are included)
        :type limit_pre_release_versions: int
        :param limit_promoted_purchases: maximum number of related promotedPurchases returned (when they are included)
        :type limit_promoted_purchases: int
        :param limit_review_submissions: maximum number of related reviewSubmissions returned (when they are included)
        :type limit_review_submissions: int
        :param limit_subscription_groups: maximum number of related subscriptionGroups returned (when they are included)
        :type limit_subscription_groups: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_get_instance_serialize(
            id=id,
            fields_apps=fields_apps,
            fields_app_encryption_declarations=fields_app_encryption_declarations,
            fields_ci_products=fields_ci_products,
            fields_beta_groups=fields_beta_groups,
            fields_app_store_versions=fields_app_store_versions,
            fields_pre_release_versions=fields_pre_release_versions,
            fields_beta_app_localizations=fields_beta_app_localizations,
            fields_builds=fields_builds,
            fields_beta_license_agreements=fields_beta_license_agreements,
            fields_beta_app_review_details=fields_beta_app_review_details,
            fields_app_infos=fields_app_infos,
            fields_app_clips=fields_app_clips,
            fields_end_user_license_agreements=fields_end_user_license_agreements,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_subscription_groups=fields_subscription_groups,
            fields_game_center_enabled_versions=fields_game_center_enabled_versions,
            fields_app_custom_product_pages=fields_app_custom_product_pages,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_app_events=fields_app_events,
            fields_review_submissions=fields_review_submissions,
            fields_subscription_grace_periods=fields_subscription_grace_periods,
            fields_game_center_details=fields_game_center_details,
            fields_app_store_version_experiments=fields_app_store_version_experiments,
            include=include,
            limit_app_clips=limit_app_clips,
            limit_app_custom_product_pages=limit_app_custom_product_pages,
            limit_app_encryption_declarations=limit_app_encryption_declarations,
            limit_app_events=limit_app_events,
            limit_app_infos=limit_app_infos,
            limit_app_store_version_experiments_v2=limit_app_store_version_experiments_v2,
            limit_app_store_versions=limit_app_store_versions,
            limit_beta_app_localizations=limit_beta_app_localizations,
            limit_beta_groups=limit_beta_groups,
            limit_builds=limit_builds,
            limit_game_center_enabled_versions=limit_game_center_enabled_versions,
            limit_in_app_purchases=limit_in_app_purchases,
            limit_in_app_purchases_v2=limit_in_app_purchases_v2,
            limit_pre_release_versions=limit_pre_release_versions,
            limit_promoted_purchases=limit_promoted_purchases,
            limit_review_submissions=limit_review_submissions,
            limit_subscription_groups=limit_subscription_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_get_instance_serialize(
        self,
        id,
        fields_apps,
        fields_app_encryption_declarations,
        fields_ci_products,
        fields_beta_groups,
        fields_app_store_versions,
        fields_pre_release_versions,
        fields_beta_app_localizations,
        fields_builds,
        fields_beta_license_agreements,
        fields_beta_app_review_details,
        fields_app_infos,
        fields_app_clips,
        fields_end_user_license_agreements,
        fields_in_app_purchases,
        fields_subscription_groups,
        fields_game_center_enabled_versions,
        fields_app_custom_product_pages,
        fields_promoted_purchases,
        fields_app_events,
        fields_review_submissions,
        fields_subscription_grace_periods,
        fields_game_center_details,
        fields_app_store_version_experiments,
        include,
        limit_app_clips,
        limit_app_custom_product_pages,
        limit_app_encryption_declarations,
        limit_app_events,
        limit_app_infos,
        limit_app_store_version_experiments_v2,
        limit_app_store_versions,
        limit_beta_app_localizations,
        limit_beta_groups,
        limit_builds,
        limit_game_center_enabled_versions,
        limit_in_app_purchases,
        limit_in_app_purchases_v2,
        limit_pre_release_versions,
        limit_promoted_purchases,
        limit_review_submissions,
        limit_subscription_groups,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[apps]': 'csv',
            'fields[appEncryptionDeclarations]': 'csv',
            'fields[ciProducts]': 'csv',
            'fields[betaGroups]': 'csv',
            'fields[appStoreVersions]': 'csv',
            'fields[preReleaseVersions]': 'csv',
            'fields[betaAppLocalizations]': 'csv',
            'fields[builds]': 'csv',
            'fields[betaLicenseAgreements]': 'csv',
            'fields[betaAppReviewDetails]': 'csv',
            'fields[appInfos]': 'csv',
            'fields[appClips]': 'csv',
            'fields[endUserLicenseAgreements]': 'csv',
            'fields[inAppPurchases]': 'csv',
            'fields[subscriptionGroups]': 'csv',
            'fields[gameCenterEnabledVersions]': 'csv',
            'fields[appCustomProductPages]': 'csv',
            'fields[promotedPurchases]': 'csv',
            'fields[appEvents]': 'csv',
            'fields[reviewSubmissions]': 'csv',
            'fields[subscriptionGracePeriods]': 'csv',
            'fields[gameCenterDetails]': 'csv',
            'fields[appStoreVersionExperiments]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_app_encryption_declarations is not None:
            
            _query_params.append(('fields[appEncryptionDeclarations]', fields_app_encryption_declarations))
            
        if fields_ci_products is not None:
            
            _query_params.append(('fields[ciProducts]', fields_ci_products))
            
        if fields_beta_groups is not None:
            
            _query_params.append(('fields[betaGroups]', fields_beta_groups))
            
        if fields_app_store_versions is not None:
            
            _query_params.append(('fields[appStoreVersions]', fields_app_store_versions))
            
        if fields_pre_release_versions is not None:
            
            _query_params.append(('fields[preReleaseVersions]', fields_pre_release_versions))
            
        if fields_beta_app_localizations is not None:
            
            _query_params.append(('fields[betaAppLocalizations]', fields_beta_app_localizations))
            
        if fields_builds is not None:
            
            _query_params.append(('fields[builds]', fields_builds))
            
        if fields_beta_license_agreements is not None:
            
            _query_params.append(('fields[betaLicenseAgreements]', fields_beta_license_agreements))
            
        if fields_beta_app_review_details is not None:
            
            _query_params.append(('fields[betaAppReviewDetails]', fields_beta_app_review_details))
            
        if fields_app_infos is not None:
            
            _query_params.append(('fields[appInfos]', fields_app_infos))
            
        if fields_app_clips is not None:
            
            _query_params.append(('fields[appClips]', fields_app_clips))
            
        if fields_end_user_license_agreements is not None:
            
            _query_params.append(('fields[endUserLicenseAgreements]', fields_end_user_license_agreements))
            
        if fields_in_app_purchases is not None:
            
            _query_params.append(('fields[inAppPurchases]', fields_in_app_purchases))
            
        if fields_subscription_groups is not None:
            
            _query_params.append(('fields[subscriptionGroups]', fields_subscription_groups))
            
        if fields_game_center_enabled_versions is not None:
            
            _query_params.append(('fields[gameCenterEnabledVersions]', fields_game_center_enabled_versions))
            
        if fields_app_custom_product_pages is not None:
            
            _query_params.append(('fields[appCustomProductPages]', fields_app_custom_product_pages))
            
        if fields_promoted_purchases is not None:
            
            _query_params.append(('fields[promotedPurchases]', fields_promoted_purchases))
            
        if fields_app_events is not None:
            
            _query_params.append(('fields[appEvents]', fields_app_events))
            
        if fields_review_submissions is not None:
            
            _query_params.append(('fields[reviewSubmissions]', fields_review_submissions))
            
        if fields_subscription_grace_periods is not None:
            
            _query_params.append(('fields[subscriptionGracePeriods]', fields_subscription_grace_periods))
            
        if fields_game_center_details is not None:
            
            _query_params.append(('fields[gameCenterDetails]', fields_game_center_details))
            
        if fields_app_store_version_experiments is not None:
            
            _query_params.append(('fields[appStoreVersionExperiments]', fields_app_store_version_experiments))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_app_clips is not None:
            
            _query_params.append(('limit[appClips]', limit_app_clips))
            
        if limit_app_custom_product_pages is not None:
            
            _query_params.append(('limit[appCustomProductPages]', limit_app_custom_product_pages))
            
        if limit_app_encryption_declarations is not None:
            
            _query_params.append(('limit[appEncryptionDeclarations]', limit_app_encryption_declarations))
            
        if limit_app_events is not None:
            
            _query_params.append(('limit[appEvents]', limit_app_events))
            
        if limit_app_infos is not None:
            
            _query_params.append(('limit[appInfos]', limit_app_infos))
            
        if limit_app_store_version_experiments_v2 is not None:
            
            _query_params.append(('limit[appStoreVersionExperimentsV2]', limit_app_store_version_experiments_v2))
            
        if limit_app_store_versions is not None:
            
            _query_params.append(('limit[appStoreVersions]', limit_app_store_versions))
            
        if limit_beta_app_localizations is not None:
            
            _query_params.append(('limit[betaAppLocalizations]', limit_beta_app_localizations))
            
        if limit_beta_groups is not None:
            
            _query_params.append(('limit[betaGroups]', limit_beta_groups))
            
        if limit_builds is not None:
            
            _query_params.append(('limit[builds]', limit_builds))
            
        if limit_game_center_enabled_versions is not None:
            
            _query_params.append(('limit[gameCenterEnabledVersions]', limit_game_center_enabled_versions))
            
        if limit_in_app_purchases is not None:
            
            _query_params.append(('limit[inAppPurchases]', limit_in_app_purchases))
            
        if limit_in_app_purchases_v2 is not None:
            
            _query_params.append(('limit[inAppPurchasesV2]', limit_in_app_purchases_v2))
            
        if limit_pre_release_versions is not None:
            
            _query_params.append(('limit[preReleaseVersions]', limit_pre_release_versions))
            
        if limit_promoted_purchases is not None:
            
            _query_params.append(('limit[promotedPurchases]', limit_promoted_purchases))
            
        if limit_review_submissions is not None:
            
            _query_params.append(('limit[reviewSubmissions]', limit_review_submissions))
            
        if limit_subscription_groups is not None:
            
            _query_params.append(('limit[subscriptionGroups]', limit_subscription_groups))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_in_app_purchases_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_in_app_purchase_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'inAppPurchaseType'")] = None,
        filter_can_be_submitted: Annotated[Optional[List[StrictStr]], Field(description="filter by canBeSubmitted")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_apps: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related apps returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> InAppPurchasesResponse:
        """(Deprecated) apps_in_app_purchases_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_in_app_purchase_type: filter by attribute 'inAppPurchaseType'
        :type filter_in_app_purchase_type: List[str]
        :param filter_can_be_submitted: filter by canBeSubmitted
        :type filter_can_be_submitted: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_apps: maximum number of related apps returned (when they are included)
        :type limit_apps: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/inAppPurchases is deprecated.", DeprecationWarning)

        _param = self._apps_in_app_purchases_get_to_many_related_serialize(
            id=id,
            filter_in_app_purchase_type=filter_in_app_purchase_type,
            filter_can_be_submitted=filter_can_be_submitted,
            sort=sort,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_apps=fields_apps,
            limit=limit,
            include=include,
            limit_apps=limit_apps,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "InAppPurchasesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_in_app_purchases_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_in_app_purchase_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'inAppPurchaseType'")] = None,
        filter_can_be_submitted: Annotated[Optional[List[StrictStr]], Field(description="filter by canBeSubmitted")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_apps: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related apps returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[InAppPurchasesResponse]:
        """(Deprecated) apps_in_app_purchases_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_in_app_purchase_type: filter by attribute 'inAppPurchaseType'
        :type filter_in_app_purchase_type: List[str]
        :param filter_can_be_submitted: filter by canBeSubmitted
        :type filter_can_be_submitted: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_apps: maximum number of related apps returned (when they are included)
        :type limit_apps: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/inAppPurchases is deprecated.", DeprecationWarning)

        _param = self._apps_in_app_purchases_get_to_many_related_serialize(
            id=id,
            filter_in_app_purchase_type=filter_in_app_purchase_type,
            filter_can_be_submitted=filter_can_be_submitted,
            sort=sort,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_apps=fields_apps,
            limit=limit,
            include=include,
            limit_apps=limit_apps,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "InAppPurchasesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_in_app_purchases_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_in_app_purchase_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'inAppPurchaseType'")] = None,
        filter_can_be_submitted: Annotated[Optional[List[StrictStr]], Field(description="filter by canBeSubmitted")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_apps: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related apps returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) apps_in_app_purchases_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_in_app_purchase_type: filter by attribute 'inAppPurchaseType'
        :type filter_in_app_purchase_type: List[str]
        :param filter_can_be_submitted: filter by canBeSubmitted
        :type filter_can_be_submitted: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_apps: maximum number of related apps returned (when they are included)
        :type limit_apps: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/inAppPurchases is deprecated.", DeprecationWarning)

        _param = self._apps_in_app_purchases_get_to_many_related_serialize(
            id=id,
            filter_in_app_purchase_type=filter_in_app_purchase_type,
            filter_can_be_submitted=filter_can_be_submitted,
            sort=sort,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_apps=fields_apps,
            limit=limit,
            include=include,
            limit_apps=limit_apps,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "InAppPurchasesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_in_app_purchases_get_to_many_related_serialize(
        self,
        id,
        filter_in_app_purchase_type,
        filter_can_be_submitted,
        sort,
        fields_in_app_purchases,
        fields_apps,
        limit,
        include,
        limit_apps,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[inAppPurchaseType]': 'csv',
            'filter[canBeSubmitted]': 'csv',
            'sort': 'csv',
            'fields[inAppPurchases]': 'csv',
            'fields[apps]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_in_app_purchase_type is not None:
            
            _query_params.append(('filter[inAppPurchaseType]', filter_in_app_purchase_type))
            
        if filter_can_be_submitted is not None:
            
            _query_params.append(('filter[canBeSubmitted]', filter_can_be_submitted))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if fields_in_app_purchases is not None:
            
            _query_params.append(('fields[inAppPurchases]', fields_in_app_purchases))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_apps is not None:
            
            _query_params.append(('limit[apps]', limit_apps))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/inAppPurchases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_in_app_purchases_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppInAppPurchasesLinkagesResponse:
        """(Deprecated) apps_in_app_purchases_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/relationships/inAppPurchases is deprecated.", DeprecationWarning)

        _param = self._apps_in_app_purchases_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppInAppPurchasesLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_in_app_purchases_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppInAppPurchasesLinkagesResponse]:
        """(Deprecated) apps_in_app_purchases_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/relationships/inAppPurchases is deprecated.", DeprecationWarning)

        _param = self._apps_in_app_purchases_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppInAppPurchasesLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_in_app_purchases_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) apps_in_app_purchases_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /v1/apps/{id}/relationships/inAppPurchases is deprecated.", DeprecationWarning)

        _param = self._apps_in_app_purchases_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppInAppPurchasesLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_in_app_purchases_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/inAppPurchases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_in_app_purchases_v2_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_product_id: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'productId'")] = None,
        filter_name: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'name'")] = None,
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        filter_in_app_purchase_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'inAppPurchaseType'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_in_app_purchase_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseLocalizations")] = None,
        fields_in_app_purchase_contents: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseContents")] = None,
        fields_in_app_purchase_app_store_review_screenshots: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots")] = None,
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_in_app_purchase_price_schedules: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchasePriceSchedules")] = None,
        fields_in_app_purchase_availabilities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseAvailabilities")] = None,
        fields_in_app_purchase_images: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseImages")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_in_app_purchase_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchaseLocalizations returned (when they are included)")] = None,
        limit_images: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related images returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> InAppPurchasesV2Response:
        """apps_in_app_purchases_v2_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_product_id: filter by attribute 'productId'
        :type filter_product_id: List[str]
        :param filter_name: filter by attribute 'name'
        :type filter_name: List[str]
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param filter_in_app_purchase_type: filter by attribute 'inAppPurchaseType'
        :type filter_in_app_purchase_type: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_in_app_purchase_localizations: the fields to include for returned resources of type inAppPurchaseLocalizations
        :type fields_in_app_purchase_localizations: List[str]
        :param fields_in_app_purchase_contents: the fields to include for returned resources of type inAppPurchaseContents
        :type fields_in_app_purchase_contents: List[str]
        :param fields_in_app_purchase_app_store_review_screenshots: the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
        :type fields_in_app_purchase_app_store_review_screenshots: List[str]
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_in_app_purchase_price_schedules: the fields to include for returned resources of type inAppPurchasePriceSchedules
        :type fields_in_app_purchase_price_schedules: List[str]
        :param fields_in_app_purchase_availabilities: the fields to include for returned resources of type inAppPurchaseAvailabilities
        :type fields_in_app_purchase_availabilities: List[str]
        :param fields_in_app_purchase_images: the fields to include for returned resources of type inAppPurchaseImages
        :type fields_in_app_purchase_images: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_in_app_purchase_localizations: maximum number of related inAppPurchaseLocalizations returned (when they are included)
        :type limit_in_app_purchase_localizations: int
        :param limit_images: maximum number of related images returned (when they are included)
        :type limit_images: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_in_app_purchases_v2_get_to_many_related_serialize(
            id=id,
            filter_product_id=filter_product_id,
            filter_name=filter_name,
            filter_state=filter_state,
            filter_in_app_purchase_type=filter_in_app_purchase_type,
            sort=sort,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_in_app_purchase_localizations=fields_in_app_purchase_localizations,
            fields_in_app_purchase_contents=fields_in_app_purchase_contents,
            fields_in_app_purchase_app_store_review_screenshots=fields_in_app_purchase_app_store_review_screenshots,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_in_app_purchase_price_schedules=fields_in_app_purchase_price_schedules,
            fields_in_app_purchase_availabilities=fields_in_app_purchase_availabilities,
            fields_in_app_purchase_images=fields_in_app_purchase_images,
            limit=limit,
            include=include,
            limit_in_app_purchase_localizations=limit_in_app_purchase_localizations,
            limit_images=limit_images,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "InAppPurchasesV2Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_in_app_purchases_v2_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_product_id: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'productId'")] = None,
        filter_name: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'name'")] = None,
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        filter_in_app_purchase_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'inAppPurchaseType'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_in_app_purchase_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseLocalizations")] = None,
        fields_in_app_purchase_contents: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseContents")] = None,
        fields_in_app_purchase_app_store_review_screenshots: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots")] = None,
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_in_app_purchase_price_schedules: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchasePriceSchedules")] = None,
        fields_in_app_purchase_availabilities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseAvailabilities")] = None,
        fields_in_app_purchase_images: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseImages")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_in_app_purchase_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchaseLocalizations returned (when they are included)")] = None,
        limit_images: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related images returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[InAppPurchasesV2Response]:
        """apps_in_app_purchases_v2_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_product_id: filter by attribute 'productId'
        :type filter_product_id: List[str]
        :param filter_name: filter by attribute 'name'
        :type filter_name: List[str]
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param filter_in_app_purchase_type: filter by attribute 'inAppPurchaseType'
        :type filter_in_app_purchase_type: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_in_app_purchase_localizations: the fields to include for returned resources of type inAppPurchaseLocalizations
        :type fields_in_app_purchase_localizations: List[str]
        :param fields_in_app_purchase_contents: the fields to include for returned resources of type inAppPurchaseContents
        :type fields_in_app_purchase_contents: List[str]
        :param fields_in_app_purchase_app_store_review_screenshots: the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
        :type fields_in_app_purchase_app_store_review_screenshots: List[str]
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_in_app_purchase_price_schedules: the fields to include for returned resources of type inAppPurchasePriceSchedules
        :type fields_in_app_purchase_price_schedules: List[str]
        :param fields_in_app_purchase_availabilities: the fields to include for returned resources of type inAppPurchaseAvailabilities
        :type fields_in_app_purchase_availabilities: List[str]
        :param fields_in_app_purchase_images: the fields to include for returned resources of type inAppPurchaseImages
        :type fields_in_app_purchase_images: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_in_app_purchase_localizations: maximum number of related inAppPurchaseLocalizations returned (when they are included)
        :type limit_in_app_purchase_localizations: int
        :param limit_images: maximum number of related images returned (when they are included)
        :type limit_images: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_in_app_purchases_v2_get_to_many_related_serialize(
            id=id,
            filter_product_id=filter_product_id,
            filter_name=filter_name,
            filter_state=filter_state,
            filter_in_app_purchase_type=filter_in_app_purchase_type,
            sort=sort,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_in_app_purchase_localizations=fields_in_app_purchase_localizations,
            fields_in_app_purchase_contents=fields_in_app_purchase_contents,
            fields_in_app_purchase_app_store_review_screenshots=fields_in_app_purchase_app_store_review_screenshots,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_in_app_purchase_price_schedules=fields_in_app_purchase_price_schedules,
            fields_in_app_purchase_availabilities=fields_in_app_purchase_availabilities,
            fields_in_app_purchase_images=fields_in_app_purchase_images,
            limit=limit,
            include=include,
            limit_in_app_purchase_localizations=limit_in_app_purchase_localizations,
            limit_images=limit_images,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "InAppPurchasesV2Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_in_app_purchases_v2_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_product_id: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'productId'")] = None,
        filter_name: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'name'")] = None,
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        filter_in_app_purchase_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'inAppPurchaseType'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_in_app_purchase_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseLocalizations")] = None,
        fields_in_app_purchase_contents: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseContents")] = None,
        fields_in_app_purchase_app_store_review_screenshots: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots")] = None,
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_in_app_purchase_price_schedules: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchasePriceSchedules")] = None,
        fields_in_app_purchase_availabilities: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseAvailabilities")] = None,
        fields_in_app_purchase_images: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchaseImages")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_in_app_purchase_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related inAppPurchaseLocalizations returned (when they are included)")] = None,
        limit_images: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related images returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_in_app_purchases_v2_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_product_id: filter by attribute 'productId'
        :type filter_product_id: List[str]
        :param filter_name: filter by attribute 'name'
        :type filter_name: List[str]
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param filter_in_app_purchase_type: filter by attribute 'inAppPurchaseType'
        :type filter_in_app_purchase_type: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_in_app_purchase_localizations: the fields to include for returned resources of type inAppPurchaseLocalizations
        :type fields_in_app_purchase_localizations: List[str]
        :param fields_in_app_purchase_contents: the fields to include for returned resources of type inAppPurchaseContents
        :type fields_in_app_purchase_contents: List[str]
        :param fields_in_app_purchase_app_store_review_screenshots: the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
        :type fields_in_app_purchase_app_store_review_screenshots: List[str]
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_in_app_purchase_price_schedules: the fields to include for returned resources of type inAppPurchasePriceSchedules
        :type fields_in_app_purchase_price_schedules: List[str]
        :param fields_in_app_purchase_availabilities: the fields to include for returned resources of type inAppPurchaseAvailabilities
        :type fields_in_app_purchase_availabilities: List[str]
        :param fields_in_app_purchase_images: the fields to include for returned resources of type inAppPurchaseImages
        :type fields_in_app_purchase_images: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_in_app_purchase_localizations: maximum number of related inAppPurchaseLocalizations returned (when they are included)
        :type limit_in_app_purchase_localizations: int
        :param limit_images: maximum number of related images returned (when they are included)
        :type limit_images: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_in_app_purchases_v2_get_to_many_related_serialize(
            id=id,
            filter_product_id=filter_product_id,
            filter_name=filter_name,
            filter_state=filter_state,
            filter_in_app_purchase_type=filter_in_app_purchase_type,
            sort=sort,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_in_app_purchase_localizations=fields_in_app_purchase_localizations,
            fields_in_app_purchase_contents=fields_in_app_purchase_contents,
            fields_in_app_purchase_app_store_review_screenshots=fields_in_app_purchase_app_store_review_screenshots,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_in_app_purchase_price_schedules=fields_in_app_purchase_price_schedules,
            fields_in_app_purchase_availabilities=fields_in_app_purchase_availabilities,
            fields_in_app_purchase_images=fields_in_app_purchase_images,
            limit=limit,
            include=include,
            limit_in_app_purchase_localizations=limit_in_app_purchase_localizations,
            limit_images=limit_images,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "InAppPurchasesV2Response",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_in_app_purchases_v2_get_to_many_related_serialize(
        self,
        id,
        filter_product_id,
        filter_name,
        filter_state,
        filter_in_app_purchase_type,
        sort,
        fields_in_app_purchases,
        fields_in_app_purchase_localizations,
        fields_in_app_purchase_contents,
        fields_in_app_purchase_app_store_review_screenshots,
        fields_promoted_purchases,
        fields_in_app_purchase_price_schedules,
        fields_in_app_purchase_availabilities,
        fields_in_app_purchase_images,
        limit,
        include,
        limit_in_app_purchase_localizations,
        limit_images,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[productId]': 'csv',
            'filter[name]': 'csv',
            'filter[state]': 'csv',
            'filter[inAppPurchaseType]': 'csv',
            'sort': 'csv',
            'fields[inAppPurchases]': 'csv',
            'fields[inAppPurchaseLocalizations]': 'csv',
            'fields[inAppPurchaseContents]': 'csv',
            'fields[inAppPurchaseAppStoreReviewScreenshots]': 'csv',
            'fields[promotedPurchases]': 'csv',
            'fields[inAppPurchasePriceSchedules]': 'csv',
            'fields[inAppPurchaseAvailabilities]': 'csv',
            'fields[inAppPurchaseImages]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_product_id is not None:
            
            _query_params.append(('filter[productId]', filter_product_id))
            
        if filter_name is not None:
            
            _query_params.append(('filter[name]', filter_name))
            
        if filter_state is not None:
            
            _query_params.append(('filter[state]', filter_state))
            
        if filter_in_app_purchase_type is not None:
            
            _query_params.append(('filter[inAppPurchaseType]', filter_in_app_purchase_type))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if fields_in_app_purchases is not None:
            
            _query_params.append(('fields[inAppPurchases]', fields_in_app_purchases))
            
        if fields_in_app_purchase_localizations is not None:
            
            _query_params.append(('fields[inAppPurchaseLocalizations]', fields_in_app_purchase_localizations))
            
        if fields_in_app_purchase_contents is not None:
            
            _query_params.append(('fields[inAppPurchaseContents]', fields_in_app_purchase_contents))
            
        if fields_in_app_purchase_app_store_review_screenshots is not None:
            
            _query_params.append(('fields[inAppPurchaseAppStoreReviewScreenshots]', fields_in_app_purchase_app_store_review_screenshots))
            
        if fields_promoted_purchases is not None:
            
            _query_params.append(('fields[promotedPurchases]', fields_promoted_purchases))
            
        if fields_in_app_purchase_price_schedules is not None:
            
            _query_params.append(('fields[inAppPurchasePriceSchedules]', fields_in_app_purchase_price_schedules))
            
        if fields_in_app_purchase_availabilities is not None:
            
            _query_params.append(('fields[inAppPurchaseAvailabilities]', fields_in_app_purchase_availabilities))
            
        if fields_in_app_purchase_images is not None:
            
            _query_params.append(('fields[inAppPurchaseImages]', fields_in_app_purchase_images))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_in_app_purchase_localizations is not None:
            
            _query_params.append(('limit[inAppPurchaseLocalizations]', limit_in_app_purchase_localizations))
            
        if limit_images is not None:
            
            _query_params.append(('limit[images]', limit_images))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/inAppPurchasesV2',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_in_app_purchases_v2_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppInAppPurchasesV2LinkagesResponse:
        """apps_in_app_purchases_v2_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_in_app_purchases_v2_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppInAppPurchasesV2LinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_in_app_purchases_v2_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppInAppPurchasesV2LinkagesResponse]:
        """apps_in_app_purchases_v2_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_in_app_purchases_v2_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppInAppPurchasesV2LinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_in_app_purchases_v2_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_in_app_purchases_v2_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_in_app_purchases_v2_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppInAppPurchasesV2LinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_in_app_purchases_v2_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/inAppPurchasesV2',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_marketplace_search_detail_get_to_one_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_marketplace_search_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type marketplaceSearchDetails")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MarketplaceSearchDetailResponse:
        """apps_marketplace_search_detail_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_marketplace_search_details: the fields to include for returned resources of type marketplaceSearchDetails
        :type fields_marketplace_search_details: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_marketplace_search_detail_get_to_one_related_serialize(
            id=id,
            fields_marketplace_search_details=fields_marketplace_search_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "MarketplaceSearchDetailResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_marketplace_search_detail_get_to_one_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_marketplace_search_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type marketplaceSearchDetails")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MarketplaceSearchDetailResponse]:
        """apps_marketplace_search_detail_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_marketplace_search_details: the fields to include for returned resources of type marketplaceSearchDetails
        :type fields_marketplace_search_details: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_marketplace_search_detail_get_to_one_related_serialize(
            id=id,
            fields_marketplace_search_details=fields_marketplace_search_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "MarketplaceSearchDetailResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_marketplace_search_detail_get_to_one_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_marketplace_search_details: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type marketplaceSearchDetails")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_marketplace_search_detail_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_marketplace_search_details: the fields to include for returned resources of type marketplaceSearchDetails
        :type fields_marketplace_search_details: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_marketplace_search_detail_get_to_one_related_serialize(
            id=id,
            fields_marketplace_search_details=fields_marketplace_search_details,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "MarketplaceSearchDetailResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_marketplace_search_detail_get_to_one_related_serialize(
        self,
        id,
        fields_marketplace_search_details,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[marketplaceSearchDetails]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_marketplace_search_details is not None:
            
            _query_params.append(('fields[marketplaceSearchDetails]', fields_marketplace_search_details))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/marketplaceSearchDetail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_marketplace_search_detail_get_to_one_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppMarketplaceSearchDetailLinkageResponse:
        """apps_marketplace_search_detail_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_marketplace_search_detail_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppMarketplaceSearchDetailLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_marketplace_search_detail_get_to_one_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppMarketplaceSearchDetailLinkageResponse]:
        """apps_marketplace_search_detail_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_marketplace_search_detail_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppMarketplaceSearchDetailLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_marketplace_search_detail_get_to_one_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_marketplace_search_detail_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_marketplace_search_detail_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppMarketplaceSearchDetailLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_marketplace_search_detail_get_to_one_relationship_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/marketplaceSearchDetail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_perf_power_metrics_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_metric_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'metricType'")] = None,
        filter_device_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceType'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> XcodeMetrics:
        """apps_perf_power_metrics_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_metric_type: filter by attribute 'metricType'
        :type filter_metric_type: List[str]
        :param filter_device_type: filter by attribute 'deviceType'
        :type filter_device_type: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_perf_power_metrics_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_metric_type=filter_metric_type,
            filter_device_type=filter_device_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "XcodeMetrics",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_perf_power_metrics_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_metric_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'metricType'")] = None,
        filter_device_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceType'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[XcodeMetrics]:
        """apps_perf_power_metrics_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_metric_type: filter by attribute 'metricType'
        :type filter_metric_type: List[str]
        :param filter_device_type: filter by attribute 'deviceType'
        :type filter_device_type: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_perf_power_metrics_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_metric_type=filter_metric_type,
            filter_device_type=filter_device_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "XcodeMetrics",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_perf_power_metrics_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_metric_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'metricType'")] = None,
        filter_device_type: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'deviceType'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_perf_power_metrics_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_metric_type: filter by attribute 'metricType'
        :type filter_metric_type: List[str]
        :param filter_device_type: filter by attribute 'deviceType'
        :type filter_device_type: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_perf_power_metrics_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_metric_type=filter_metric_type,
            filter_device_type=filter_device_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "XcodeMetrics",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_perf_power_metrics_get_to_many_related_serialize(
        self,
        id,
        filter_platform,
        filter_metric_type,
        filter_device_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[platform]': 'csv',
            'filter[metricType]': 'csv',
            'filter[deviceType]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_platform is not None:
            
            _query_params.append(('filter[platform]', filter_platform))
            
        if filter_metric_type is not None:
            
            _query_params.append(('filter[metricType]', filter_metric_type))
            
        if filter_device_type is not None:
            
            _query_params.append(('filter[deviceType]', filter_device_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/vnd.apple.xcode-metrics+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/perfPowerMetrics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_pre_release_versions_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_pre_release_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type preReleaseVersions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PreReleaseVersionsWithoutIncludesResponse:
        """apps_pre_release_versions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_pre_release_versions: the fields to include for returned resources of type preReleaseVersions
        :type fields_pre_release_versions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_pre_release_versions_get_to_many_related_serialize(
            id=id,
            fields_pre_release_versions=fields_pre_release_versions,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "PreReleaseVersionsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_pre_release_versions_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_pre_release_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type preReleaseVersions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PreReleaseVersionsWithoutIncludesResponse]:
        """apps_pre_release_versions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_pre_release_versions: the fields to include for returned resources of type preReleaseVersions
        :type fields_pre_release_versions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_pre_release_versions_get_to_many_related_serialize(
            id=id,
            fields_pre_release_versions=fields_pre_release_versions,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "PreReleaseVersionsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_pre_release_versions_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_pre_release_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type preReleaseVersions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_pre_release_versions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_pre_release_versions: the fields to include for returned resources of type preReleaseVersions
        :type fields_pre_release_versions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_pre_release_versions_get_to_many_related_serialize(
            id=id,
            fields_pre_release_versions=fields_pre_release_versions,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "PreReleaseVersionsWithoutIncludesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_pre_release_versions_get_to_many_related_serialize(
        self,
        id,
        fields_pre_release_versions,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[preReleaseVersions]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_pre_release_versions is not None:
            
            _query_params.append(('fields[preReleaseVersions]', fields_pre_release_versions))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/preReleaseVersions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_pre_release_versions_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppPreReleaseVersionsLinkagesResponse:
        """apps_pre_release_versions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_pre_release_versions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPreReleaseVersionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_pre_release_versions_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppPreReleaseVersionsLinkagesResponse]:
        """apps_pre_release_versions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_pre_release_versions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPreReleaseVersionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_pre_release_versions_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_pre_release_versions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_pre_release_versions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPreReleaseVersionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_pre_release_versions_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/preReleaseVersions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_promoted_purchases_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_subscriptions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PromotedPurchasesResponse:
        """apps_promoted_purchases_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_subscriptions: the fields to include for returned resources of type subscriptions
        :type fields_subscriptions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_promoted_purchases_get_to_many_related_serialize(
            id=id,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_subscriptions=fields_subscriptions,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "PromotedPurchasesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_promoted_purchases_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_subscriptions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PromotedPurchasesResponse]:
        """apps_promoted_purchases_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_subscriptions: the fields to include for returned resources of type subscriptions
        :type fields_subscriptions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_promoted_purchases_get_to_many_related_serialize(
            id=id,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_subscriptions=fields_subscriptions,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "PromotedPurchasesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_promoted_purchases_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_promoted_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type promotedPurchases")] = None,
        fields_in_app_purchases: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type inAppPurchases")] = None,
        fields_subscriptions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptions")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_promoted_purchases_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_promoted_purchases: the fields to include for returned resources of type promotedPurchases
        :type fields_promoted_purchases: List[str]
        :param fields_in_app_purchases: the fields to include for returned resources of type inAppPurchases
        :type fields_in_app_purchases: List[str]
        :param fields_subscriptions: the fields to include for returned resources of type subscriptions
        :type fields_subscriptions: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_promoted_purchases_get_to_many_related_serialize(
            id=id,
            fields_promoted_purchases=fields_promoted_purchases,
            fields_in_app_purchases=fields_in_app_purchases,
            fields_subscriptions=fields_subscriptions,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "PromotedPurchasesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_promoted_purchases_get_to_many_related_serialize(
        self,
        id,
        fields_promoted_purchases,
        fields_in_app_purchases,
        fields_subscriptions,
        limit,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[promotedPurchases]': 'csv',
            'fields[inAppPurchases]': 'csv',
            'fields[subscriptions]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_promoted_purchases is not None:
            
            _query_params.append(('fields[promotedPurchases]', fields_promoted_purchases))
            
        if fields_in_app_purchases is not None:
            
            _query_params.append(('fields[inAppPurchases]', fields_in_app_purchases))
            
        if fields_subscriptions is not None:
            
            _query_params.append(('fields[subscriptions]', fields_subscriptions))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/promotedPurchases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_promoted_purchases_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppPromotedPurchasesLinkagesResponse:
        """apps_promoted_purchases_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_promoted_purchases_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPromotedPurchasesLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_promoted_purchases_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppPromotedPurchasesLinkagesResponse]:
        """apps_promoted_purchases_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_promoted_purchases_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPromotedPurchasesLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_promoted_purchases_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_promoted_purchases_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_promoted_purchases_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppPromotedPurchasesLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_promoted_purchases_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/promotedPurchases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_promoted_purchases_replace_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        app_promoted_purchases_linkages_request: Annotated[AppPromotedPurchasesLinkagesRequest, Field(description="List of related linkages")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """apps_promoted_purchases_replace_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param app_promoted_purchases_linkages_request: List of related linkages (required)
        :type app_promoted_purchases_linkages_request: AppPromotedPurchasesLinkagesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_promoted_purchases_replace_to_many_relationship_serialize(
            id=id,
            app_promoted_purchases_linkages_request=app_promoted_purchases_linkages_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '422': "ErrorResponse",
            '409': "ErrorResponse",
            '204': None,
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_promoted_purchases_replace_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        app_promoted_purchases_linkages_request: Annotated[AppPromotedPurchasesLinkagesRequest, Field(description="List of related linkages")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """apps_promoted_purchases_replace_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param app_promoted_purchases_linkages_request: List of related linkages (required)
        :type app_promoted_purchases_linkages_request: AppPromotedPurchasesLinkagesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_promoted_purchases_replace_to_many_relationship_serialize(
            id=id,
            app_promoted_purchases_linkages_request=app_promoted_purchases_linkages_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '422': "ErrorResponse",
            '409': "ErrorResponse",
            '204': None,
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_promoted_purchases_replace_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        app_promoted_purchases_linkages_request: Annotated[AppPromotedPurchasesLinkagesRequest, Field(description="List of related linkages")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_promoted_purchases_replace_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param app_promoted_purchases_linkages_request: List of related linkages (required)
        :type app_promoted_purchases_linkages_request: AppPromotedPurchasesLinkagesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_promoted_purchases_replace_to_many_relationship_serialize(
            id=id,
            app_promoted_purchases_linkages_request=app_promoted_purchases_linkages_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '422': "ErrorResponse",
            '409': "ErrorResponse",
            '204': None,
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_promoted_purchases_replace_to_many_relationship_serialize(
        self,
        id,
        app_promoted_purchases_linkages_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if app_promoted_purchases_linkages_request is not None:
            _body_params = app_promoted_purchases_linkages_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/v1/apps/{id}/relationships/promotedPurchases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_review_submissions_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        fields_review_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissions")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_review_submission_items: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissionItems")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_actors: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type actors")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_items: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related items returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ReviewSubmissionsResponse:
        """apps_review_submissions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param fields_review_submissions: the fields to include for returned resources of type reviewSubmissions
        :type fields_review_submissions: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_review_submission_items: the fields to include for returned resources of type reviewSubmissionItems
        :type fields_review_submission_items: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_actors: the fields to include for returned resources of type actors
        :type fields_actors: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_items: maximum number of related items returned (when they are included)
        :type limit_items: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_review_submissions_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_state=filter_state,
            fields_review_submissions=fields_review_submissions,
            fields_apps=fields_apps,
            fields_review_submission_items=fields_review_submission_items,
            fields_app_store_versions=fields_app_store_versions,
            fields_actors=fields_actors,
            limit=limit,
            include=include,
            limit_items=limit_items,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "ReviewSubmissionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_review_submissions_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        fields_review_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissions")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_review_submission_items: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissionItems")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_actors: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type actors")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_items: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related items returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ReviewSubmissionsResponse]:
        """apps_review_submissions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param fields_review_submissions: the fields to include for returned resources of type reviewSubmissions
        :type fields_review_submissions: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_review_submission_items: the fields to include for returned resources of type reviewSubmissionItems
        :type fields_review_submission_items: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_actors: the fields to include for returned resources of type actors
        :type fields_actors: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_items: maximum number of related items returned (when they are included)
        :type limit_items: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_review_submissions_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_state=filter_state,
            fields_review_submissions=fields_review_submissions,
            fields_apps=fields_apps,
            fields_review_submission_items=fields_review_submission_items,
            fields_app_store_versions=fields_app_store_versions,
            fields_actors=fields_actors,
            limit=limit,
            include=include,
            limit_items=limit_items,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "ReviewSubmissionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_review_submissions_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_platform: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'platform'")] = None,
        filter_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'state'")] = None,
        fields_review_submissions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissions")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        fields_review_submission_items: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type reviewSubmissionItems")] = None,
        fields_app_store_versions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type appStoreVersions")] = None,
        fields_actors: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type actors")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_items: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related items returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_review_submissions_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_platform: filter by attribute 'platform'
        :type filter_platform: List[str]
        :param filter_state: filter by attribute 'state'
        :type filter_state: List[str]
        :param fields_review_submissions: the fields to include for returned resources of type reviewSubmissions
        :type fields_review_submissions: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param fields_review_submission_items: the fields to include for returned resources of type reviewSubmissionItems
        :type fields_review_submission_items: List[str]
        :param fields_app_store_versions: the fields to include for returned resources of type appStoreVersions
        :type fields_app_store_versions: List[str]
        :param fields_actors: the fields to include for returned resources of type actors
        :type fields_actors: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_items: maximum number of related items returned (when they are included)
        :type limit_items: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_review_submissions_get_to_many_related_serialize(
            id=id,
            filter_platform=filter_platform,
            filter_state=filter_state,
            fields_review_submissions=fields_review_submissions,
            fields_apps=fields_apps,
            fields_review_submission_items=fields_review_submission_items,
            fields_app_store_versions=fields_app_store_versions,
            fields_actors=fields_actors,
            limit=limit,
            include=include,
            limit_items=limit_items,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "ReviewSubmissionsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_review_submissions_get_to_many_related_serialize(
        self,
        id,
        filter_platform,
        filter_state,
        fields_review_submissions,
        fields_apps,
        fields_review_submission_items,
        fields_app_store_versions,
        fields_actors,
        limit,
        include,
        limit_items,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[platform]': 'csv',
            'filter[state]': 'csv',
            'fields[reviewSubmissions]': 'csv',
            'fields[apps]': 'csv',
            'fields[reviewSubmissionItems]': 'csv',
            'fields[appStoreVersions]': 'csv',
            'fields[actors]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_platform is not None:
            
            _query_params.append(('filter[platform]', filter_platform))
            
        if filter_state is not None:
            
            _query_params.append(('filter[state]', filter_state))
            
        if fields_review_submissions is not None:
            
            _query_params.append(('fields[reviewSubmissions]', fields_review_submissions))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if fields_review_submission_items is not None:
            
            _query_params.append(('fields[reviewSubmissionItems]', fields_review_submission_items))
            
        if fields_app_store_versions is not None:
            
            _query_params.append(('fields[appStoreVersions]', fields_app_store_versions))
            
        if fields_actors is not None:
            
            _query_params.append(('fields[actors]', fields_actors))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_items is not None:
            
            _query_params.append(('limit[items]', limit_items))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/reviewSubmissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_review_submissions_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppReviewSubmissionsLinkagesResponse:
        """apps_review_submissions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_review_submissions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppReviewSubmissionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_review_submissions_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppReviewSubmissionsLinkagesResponse]:
        """apps_review_submissions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_review_submissions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppReviewSubmissionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_review_submissions_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_review_submissions_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_review_submissions_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppReviewSubmissionsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_review_submissions_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/reviewSubmissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_subscription_grace_period_get_to_one_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_subscription_grace_periods: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGracePeriods")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SubscriptionGracePeriodResponse:
        """apps_subscription_grace_period_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_subscription_grace_periods: the fields to include for returned resources of type subscriptionGracePeriods
        :type fields_subscription_grace_periods: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_grace_period_get_to_one_related_serialize(
            id=id,
            fields_subscription_grace_periods=fields_subscription_grace_periods,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "SubscriptionGracePeriodResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_subscription_grace_period_get_to_one_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_subscription_grace_periods: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGracePeriods")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SubscriptionGracePeriodResponse]:
        """apps_subscription_grace_period_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_subscription_grace_periods: the fields to include for returned resources of type subscriptionGracePeriods
        :type fields_subscription_grace_periods: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_grace_period_get_to_one_related_serialize(
            id=id,
            fields_subscription_grace_periods=fields_subscription_grace_periods,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "SubscriptionGracePeriodResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_subscription_grace_period_get_to_one_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_subscription_grace_periods: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGracePeriods")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_subscription_grace_period_get_to_one_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_subscription_grace_periods: the fields to include for returned resources of type subscriptionGracePeriods
        :type fields_subscription_grace_periods: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_grace_period_get_to_one_related_serialize(
            id=id,
            fields_subscription_grace_periods=fields_subscription_grace_periods,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "SubscriptionGracePeriodResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_subscription_grace_period_get_to_one_related_serialize(
        self,
        id,
        fields_subscription_grace_periods,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[subscriptionGracePeriods]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_subscription_grace_periods is not None:
            
            _query_params.append(('fields[subscriptionGracePeriods]', fields_subscription_grace_periods))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/subscriptionGracePeriod',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_subscription_grace_period_get_to_one_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppSubscriptionGracePeriodLinkageResponse:
        """apps_subscription_grace_period_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_grace_period_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppSubscriptionGracePeriodLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_subscription_grace_period_get_to_one_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppSubscriptionGracePeriodLinkageResponse]:
        """apps_subscription_grace_period_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_grace_period_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppSubscriptionGracePeriodLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_subscription_grace_period_get_to_one_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_subscription_grace_period_get_to_one_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_grace_period_get_to_one_relationship_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppSubscriptionGracePeriodLinkageResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_subscription_grace_period_get_to_one_relationship_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/subscriptionGracePeriod',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_subscription_groups_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_reference_name: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'referenceName'")] = None,
        filter_subscriptions_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'subscriptions.state'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_subscription_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroups")] = None,
        fields_subscriptions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptions")] = None,
        fields_subscription_group_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroupLocalizations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_subscriptions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptions returned (when they are included)")] = None,
        limit_subscription_group_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptionGroupLocalizations returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SubscriptionGroupsResponse:
        """apps_subscription_groups_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_reference_name: filter by attribute 'referenceName'
        :type filter_reference_name: List[str]
        :param filter_subscriptions_state: filter by attribute 'subscriptions.state'
        :type filter_subscriptions_state: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_subscription_groups: the fields to include for returned resources of type subscriptionGroups
        :type fields_subscription_groups: List[str]
        :param fields_subscriptions: the fields to include for returned resources of type subscriptions
        :type fields_subscriptions: List[str]
        :param fields_subscription_group_localizations: the fields to include for returned resources of type subscriptionGroupLocalizations
        :type fields_subscription_group_localizations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_subscriptions: maximum number of related subscriptions returned (when they are included)
        :type limit_subscriptions: int
        :param limit_subscription_group_localizations: maximum number of related subscriptionGroupLocalizations returned (when they are included)
        :type limit_subscription_group_localizations: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_groups_get_to_many_related_serialize(
            id=id,
            filter_reference_name=filter_reference_name,
            filter_subscriptions_state=filter_subscriptions_state,
            sort=sort,
            fields_subscription_groups=fields_subscription_groups,
            fields_subscriptions=fields_subscriptions,
            fields_subscription_group_localizations=fields_subscription_group_localizations,
            limit=limit,
            include=include,
            limit_subscriptions=limit_subscriptions,
            limit_subscription_group_localizations=limit_subscription_group_localizations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "SubscriptionGroupsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_subscription_groups_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_reference_name: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'referenceName'")] = None,
        filter_subscriptions_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'subscriptions.state'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_subscription_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroups")] = None,
        fields_subscriptions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptions")] = None,
        fields_subscription_group_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroupLocalizations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_subscriptions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptions returned (when they are included)")] = None,
        limit_subscription_group_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptionGroupLocalizations returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SubscriptionGroupsResponse]:
        """apps_subscription_groups_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_reference_name: filter by attribute 'referenceName'
        :type filter_reference_name: List[str]
        :param filter_subscriptions_state: filter by attribute 'subscriptions.state'
        :type filter_subscriptions_state: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_subscription_groups: the fields to include for returned resources of type subscriptionGroups
        :type fields_subscription_groups: List[str]
        :param fields_subscriptions: the fields to include for returned resources of type subscriptions
        :type fields_subscriptions: List[str]
        :param fields_subscription_group_localizations: the fields to include for returned resources of type subscriptionGroupLocalizations
        :type fields_subscription_group_localizations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_subscriptions: maximum number of related subscriptions returned (when they are included)
        :type limit_subscriptions: int
        :param limit_subscription_group_localizations: maximum number of related subscriptionGroupLocalizations returned (when they are included)
        :type limit_subscription_group_localizations: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_groups_get_to_many_related_serialize(
            id=id,
            filter_reference_name=filter_reference_name,
            filter_subscriptions_state=filter_subscriptions_state,
            sort=sort,
            fields_subscription_groups=fields_subscription_groups,
            fields_subscriptions=fields_subscriptions,
            fields_subscription_group_localizations=fields_subscription_group_localizations,
            limit=limit,
            include=include,
            limit_subscriptions=limit_subscriptions,
            limit_subscription_group_localizations=limit_subscription_group_localizations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "SubscriptionGroupsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_subscription_groups_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        filter_reference_name: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'referenceName'")] = None,
        filter_subscriptions_state: Annotated[Optional[List[StrictStr]], Field(description="filter by attribute 'subscriptions.state'")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of sort expressions; resources will be sorted as specified")] = None,
        fields_subscription_groups: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroups")] = None,
        fields_subscriptions: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptions")] = None,
        fields_subscription_group_localizations: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type subscriptionGroupLocalizations")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        limit_subscriptions: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptions returned (when they are included)")] = None,
        limit_subscription_group_localizations: Annotated[Optional[Annotated[int, Field(le=50, strict=True)]], Field(description="maximum number of related subscriptionGroupLocalizations returned (when they are included)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_subscription_groups_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param filter_reference_name: filter by attribute 'referenceName'
        :type filter_reference_name: List[str]
        :param filter_subscriptions_state: filter by attribute 'subscriptions.state'
        :type filter_subscriptions_state: List[str]
        :param sort: comma-separated list of sort expressions; resources will be sorted as specified
        :type sort: List[str]
        :param fields_subscription_groups: the fields to include for returned resources of type subscriptionGroups
        :type fields_subscription_groups: List[str]
        :param fields_subscriptions: the fields to include for returned resources of type subscriptions
        :type fields_subscriptions: List[str]
        :param fields_subscription_group_localizations: the fields to include for returned resources of type subscriptionGroupLocalizations
        :type fields_subscription_group_localizations: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param limit_subscriptions: maximum number of related subscriptions returned (when they are included)
        :type limit_subscriptions: int
        :param limit_subscription_group_localizations: maximum number of related subscriptionGroupLocalizations returned (when they are included)
        :type limit_subscription_group_localizations: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_groups_get_to_many_related_serialize(
            id=id,
            filter_reference_name=filter_reference_name,
            filter_subscriptions_state=filter_subscriptions_state,
            sort=sort,
            fields_subscription_groups=fields_subscription_groups,
            fields_subscriptions=fields_subscriptions,
            fields_subscription_group_localizations=fields_subscription_group_localizations,
            limit=limit,
            include=include,
            limit_subscriptions=limit_subscriptions,
            limit_subscription_group_localizations=limit_subscription_group_localizations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "SubscriptionGroupsResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_subscription_groups_get_to_many_related_serialize(
        self,
        id,
        filter_reference_name,
        filter_subscriptions_state,
        sort,
        fields_subscription_groups,
        fields_subscriptions,
        fields_subscription_group_localizations,
        limit,
        include,
        limit_subscriptions,
        limit_subscription_group_localizations,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter[referenceName]': 'csv',
            'filter[subscriptions.state]': 'csv',
            'sort': 'csv',
            'fields[subscriptionGroups]': 'csv',
            'fields[subscriptions]': 'csv',
            'fields[subscriptionGroupLocalizations]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if filter_reference_name is not None:
            
            _query_params.append(('filter[referenceName]', filter_reference_name))
            
        if filter_subscriptions_state is not None:
            
            _query_params.append(('filter[subscriptions.state]', filter_subscriptions_state))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if fields_subscription_groups is not None:
            
            _query_params.append(('fields[subscriptionGroups]', fields_subscription_groups))
            
        if fields_subscriptions is not None:
            
            _query_params.append(('fields[subscriptions]', fields_subscriptions))
            
        if fields_subscription_group_localizations is not None:
            
            _query_params.append(('fields[subscriptionGroupLocalizations]', fields_subscription_group_localizations))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        if limit_subscriptions is not None:
            
            _query_params.append(('limit[subscriptions]', limit_subscriptions))
            
        if limit_subscription_group_localizations is not None:
            
            _query_params.append(('limit[subscriptionGroupLocalizations]', limit_subscription_group_localizations))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/subscriptionGroups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_subscription_groups_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppSubscriptionGroupsLinkagesResponse:
        """apps_subscription_groups_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_groups_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppSubscriptionGroupsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_subscription_groups_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppSubscriptionGroupsLinkagesResponse]:
        """apps_subscription_groups_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_groups_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppSubscriptionGroupsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_subscription_groups_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_subscription_groups_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_subscription_groups_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppSubscriptionGroupsLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_subscription_groups_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/subscriptionGroups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_update_instance(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        app_update_request: Annotated[AppUpdateRequest, Field(description="App representation")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppResponse:
        """apps_update_instance


        :param id: the id of the requested resource (required)
        :type id: str
        :param app_update_request: App representation (required)
        :type app_update_request: AppUpdateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_update_instance_serialize(
            id=id,
            app_update_request=app_update_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '422': "ErrorResponse",
            '200': "AppResponse",
            '409': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_update_instance_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        app_update_request: Annotated[AppUpdateRequest, Field(description="App representation")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppResponse]:
        """apps_update_instance


        :param id: the id of the requested resource (required)
        :type id: str
        :param app_update_request: App representation (required)
        :type app_update_request: AppUpdateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_update_instance_serialize(
            id=id,
            app_update_request=app_update_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '422': "ErrorResponse",
            '200': "AppResponse",
            '409': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_update_instance_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        app_update_request: Annotated[AppUpdateRequest, Field(description="App representation")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_update_instance


        :param id: the id of the requested resource (required)
        :type id: str
        :param app_update_request: App representation (required)
        :type app_update_request: AppUpdateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_update_instance_serialize(
            id=id,
            app_update_request=app_update_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '422': "ErrorResponse",
            '200': "AppResponse",
            '409': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_update_instance_serialize(
        self,
        id,
        app_update_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if app_update_request is not None:
            _body_params = app_update_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/v1/apps/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_webhooks_get_to_many_related(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_webhooks: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type webhooks")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WebhooksResponse:
        """apps_webhooks_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_webhooks: the fields to include for returned resources of type webhooks
        :type fields_webhooks: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_webhooks_get_to_many_related_serialize(
            id=id,
            fields_webhooks=fields_webhooks,
            fields_apps=fields_apps,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "WebhooksResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_webhooks_get_to_many_related_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_webhooks: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type webhooks")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WebhooksResponse]:
        """apps_webhooks_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_webhooks: the fields to include for returned resources of type webhooks
        :type fields_webhooks: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_webhooks_get_to_many_related_serialize(
            id=id,
            fields_webhooks=fields_webhooks,
            fields_apps=fields_apps,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "WebhooksResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_webhooks_get_to_many_related_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        fields_webhooks: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type webhooks")] = None,
        fields_apps: Annotated[Optional[List[StrictStr]], Field(description="the fields to include for returned resources of type apps")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        include: Annotated[Optional[List[StrictStr]], Field(description="comma-separated list of relationships to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_webhooks_get_to_many_related


        :param id: the id of the requested resource (required)
        :type id: str
        :param fields_webhooks: the fields to include for returned resources of type webhooks
        :type fields_webhooks: List[str]
        :param fields_apps: the fields to include for returned resources of type apps
        :type fields_apps: List[str]
        :param limit: maximum resources per page
        :type limit: int
        :param include: comma-separated list of relationships to include
        :type include: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_webhooks_get_to_many_related_serialize(
            id=id,
            fields_webhooks=fields_webhooks,
            fields_apps=fields_apps,
            limit=limit,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "WebhooksResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_webhooks_get_to_many_related_serialize(
        self,
        id,
        fields_webhooks,
        fields_apps,
        limit,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields[webhooks]': 'csv',
            'fields[apps]': 'csv',
            'include': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if fields_webhooks is not None:
            
            _query_params.append(('fields[webhooks]', fields_webhooks))
            
        if fields_apps is not None:
            
            _query_params.append(('fields[apps]', fields_apps))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/webhooks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def apps_webhooks_get_to_many_relationship(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppWebhooksLinkagesResponse:
        """apps_webhooks_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_webhooks_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppWebhooksLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def apps_webhooks_get_to_many_relationship_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AppWebhooksLinkagesResponse]:
        """apps_webhooks_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_webhooks_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppWebhooksLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def apps_webhooks_get_to_many_relationship_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="the id of the requested resource")],
        limit: Annotated[Optional[Annotated[int, Field(le=200, strict=True)]], Field(description="maximum resources per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apps_webhooks_get_to_many_relationship


        :param id: the id of the requested resource (required)
        :type id: str
        :param limit: maximum resources per page
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apps_webhooks_get_to_many_relationship_serialize(
            id=id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '200': "AppWebhooksLinkagesResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apps_webhooks_get_to_many_relationship_serialize(
        self,
        id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'itc-bearer-token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/apps/{id}/relationships/webhooks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


